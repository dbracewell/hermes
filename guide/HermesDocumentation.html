<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=KAcgnVa0IBppVRWtHAiHYquCQmIIa9sm9nBQ4AChcoU');.lst-kix_w4y7hkbtg4ow-1>li:before{content:"\0025cb  "}.lst-kix_w4y7hkbtg4ow-3>li:before{content:"\0025cf  "}.lst-kix_w4y7hkbtg4ow-0>li:before{content:"\0025cf  "}.lst-kix_w4y7hkbtg4ow-4>li:before{content:"\0025cb  "}ul.lst-kix_c1iujowgdv8g-6{list-style-type:none}.lst-kix_c1iujowgdv8g-8>li:before{content:"\0025a0  "}ul.lst-kix_c1iujowgdv8g-5{list-style-type:none}ul.lst-kix_c1iujowgdv8g-8{list-style-type:none}ul.lst-kix_c1iujowgdv8g-7{list-style-type:none}ul.lst-kix_c1iujowgdv8g-2{list-style-type:none}ul.lst-kix_c1iujowgdv8g-1{list-style-type:none}.lst-kix_pieid35nlkcr-0>li:before{content:"" counter(lst-ctn-kix_pieid35nlkcr-0,decimal) ". "}ul.lst-kix_c1iujowgdv8g-4{list-style-type:none}.lst-kix_t7afhzt26ilu-8>li:before{content:"\0025a0  "}.lst-kix_9l3xhk2sexv6-1>li:before{content:"\0025cb  "}.lst-kix_w4y7hkbtg4ow-2>li:before{content:"\0025a0  "}ul.lst-kix_c1iujowgdv8g-3{list-style-type:none}.lst-kix_pieid35nlkcr-3>li:before{content:"\0025cf  "}ul.lst-kix_uv263b97act8-7{list-style-type:none}ul.lst-kix_uv263b97act8-8{list-style-type:none}ul.lst-kix_c1iujowgdv8g-0{list-style-type:none}ul.lst-kix_uv263b97act8-5{list-style-type:none}.lst-kix_9l3xhk2sexv6-2>li:before{content:"\0025a0  "}ul.lst-kix_uv263b97act8-6{list-style-type:none}.lst-kix_pieid35nlkcr-1>li:before{content:"\0025cb  "}.lst-kix_pieid35nlkcr-5>li:before{content:"\0025a0  "}ul.lst-kix_uv263b97act8-3{list-style-type:none}.lst-kix_uv263b97act8-0>li:before{content:"\0025cf  "}ul.lst-kix_uv263b97act8-4{list-style-type:none}.lst-kix_pieid35nlkcr-2>li:before{content:"\0025a0  "}.lst-kix_pieid35nlkcr-6>li:before{content:"\0025cf  "}ul.lst-kix_uv263b97act8-1{list-style-type:none}.lst-kix_9l3xhk2sexv6-3>li:before{content:"\0025cf  "}ul.lst-kix_uv263b97act8-2{list-style-type:none}.lst-kix_9l3xhk2sexv6-0>li{counter-increment:lst-ctn-kix_9l3xhk2sexv6-0}ul.lst-kix_uv263b97act8-0{list-style-type:none}.lst-kix_9l3xhk2sexv6-4>li:before{content:"\0025cb  "}.lst-kix_9l3xhk2sexv6-6>li:before{content:"\0025cf  "}.lst-kix_pieid35nlkcr-4>li:before{content:"\0025cb  "}.lst-kix_9l3xhk2sexv6-5>li:before{content:"\0025a0  "}.lst-kix_c1iujowgdv8g-0>li:before{content:"\0025cf  "}ol.lst-kix_9l3xhk2sexv6-0{list-style-type:none}ol.lst-kix_pieid35nlkcr-0.start{counter-reset:lst-ctn-kix_pieid35nlkcr-0 0}.lst-kix_t7afhzt26ilu-1>li:before{content:"\0025cb  "}.lst-kix_c1iujowgdv8g-1>li:before{content:"\0025cb  "}.lst-kix_c1iujowgdv8g-2>li:before{content:"\0025a0  "}.lst-kix_t7afhzt26ilu-0>li:before{content:"\0025cf  "}.lst-kix_c1iujowgdv8g-4>li:before{content:"\0025cb  "}ul.lst-kix_t7afhzt26ilu-4{list-style-type:none}.lst-kix_t7afhzt26ilu-5>li:before{content:"\0025a0  "}ul.lst-kix_t7afhzt26ilu-3{list-style-type:none}.lst-kix_c1iujowgdv8g-3>li:before{content:"\0025cf  "}.lst-kix_c1iujowgdv8g-5>li:before{content:"\0025a0  "}ul.lst-kix_t7afhzt26ilu-2{list-style-type:none}.lst-kix_9l3xhk2sexv6-0>li:before{content:"" counter(lst-ctn-kix_9l3xhk2sexv6-0,decimal) ". "}ul.lst-kix_t7afhzt26ilu-1{list-style-type:none}ul.lst-kix_t7afhzt26ilu-0{list-style-type:none}.lst-kix_t7afhzt26ilu-3>li:before{content:"\0025cf  "}.lst-kix_t7afhzt26ilu-7>li:before{content:"\0025cb  "}.lst-kix_t7afhzt26ilu-2>li:before{content:"\0025a0  "}.lst-kix_t7afhzt26ilu-6>li:before{content:"\0025cf  "}.lst-kix_w4y7hkbtg4ow-8>li:before{content:"\0025a0  "}.lst-kix_c1iujowgdv8g-7>li:before{content:"\0025cb  "}.lst-kix_w4y7hkbtg4ow-5>li:before{content:"\0025a0  "}.lst-kix_w4y7hkbtg4ow-7>li:before{content:"\0025cb  "}ol.lst-kix_9l3xhk2sexv6-0.start{counter-reset:lst-ctn-kix_9l3xhk2sexv6-0 0}.lst-kix_c1iujowgdv8g-6>li:before{content:"\0025cf  "}ul.lst-kix_t7afhzt26ilu-8{list-style-type:none}ul.lst-kix_t7afhzt26ilu-7{list-style-type:none}.lst-kix_t7afhzt26ilu-4>li:before{content:"\0025cb  "}ul.lst-kix_t7afhzt26ilu-6{list-style-type:none}.lst-kix_w4y7hkbtg4ow-6>li:before{content:"\0025cf  "}ul.lst-kix_t7afhzt26ilu-5{list-style-type:none}ul.lst-kix_9l3xhk2sexv6-1{list-style-type:none}ol.lst-kix_pieid35nlkcr-0{list-style-type:none}ul.lst-kix_9l3xhk2sexv6-5{list-style-type:none}ul.lst-kix_w4y7hkbtg4ow-6{list-style-type:none}ul.lst-kix_9l3xhk2sexv6-4{list-style-type:none}ul.lst-kix_w4y7hkbtg4ow-7{list-style-type:none}ul.lst-kix_9l3xhk2sexv6-3{list-style-type:none}ul.lst-kix_w4y7hkbtg4ow-4{list-style-type:none}ul.lst-kix_9l3xhk2sexv6-2{list-style-type:none}ul.lst-kix_w4y7hkbtg4ow-5{list-style-type:none}ul.lst-kix_9l3xhk2sexv6-8{list-style-type:none}ul.lst-kix_9l3xhk2sexv6-7{list-style-type:none}ul.lst-kix_w4y7hkbtg4ow-8{list-style-type:none}ul.lst-kix_9l3xhk2sexv6-6{list-style-type:none}ul.lst-kix_w4y7hkbtg4ow-2{list-style-type:none}ul.lst-kix_w4y7hkbtg4ow-3{list-style-type:none}ul.lst-kix_w4y7hkbtg4ow-0{list-style-type:none}ul.lst-kix_w4y7hkbtg4ow-1{list-style-type:none}.lst-kix_9l3xhk2sexv6-8>li:before{content:"\0025a0  "}.lst-kix_9l3xhk2sexv6-7>li:before{content:"\0025cb  "}.lst-kix_pieid35nlkcr-7>li:before{content:"\0025cb  "}.lst-kix_pieid35nlkcr-8>li:before{content:"\0025a0  "}ul.lst-kix_pieid35nlkcr-3{list-style-type:none}ul.lst-kix_pieid35nlkcr-2{list-style-type:none}ul.lst-kix_pieid35nlkcr-5{list-style-type:none}.lst-kix_8r7ty3cdanh8-1>li:before{content:"\0025cb  "}ul.lst-kix_pieid35nlkcr-4{list-style-type:none}.lst-kix_pieid35nlkcr-0>li{counter-increment:lst-ctn-kix_pieid35nlkcr-0}ul.lst-kix_pieid35nlkcr-1{list-style-type:none}.lst-kix_8r7ty3cdanh8-2>li:before{content:"\0025a0  "}.lst-kix_8r7ty3cdanh8-3>li:before{content:"\0025cf  "}.lst-kix_8r7ty3cdanh8-5>li:before{content:"\0025a0  "}ul.lst-kix_pieid35nlkcr-7{list-style-type:none}ul.lst-kix_pieid35nlkcr-6{list-style-type:none}.lst-kix_8r7ty3cdanh8-4>li:before{content:"\0025cb  "}ul.lst-kix_pieid35nlkcr-8{list-style-type:none}.lst-kix_8r7ty3cdanh8-7>li:before{content:"\0025cb  "}.lst-kix_8r7ty3cdanh8-6>li:before{content:"\0025cf  "}.lst-kix_8r7ty3cdanh8-8>li:before{content:"\0025a0  "}.lst-kix_8r7ty3cdanh8-0>li:before{content:"\0025cf  "}ul.lst-kix_8r7ty3cdanh8-1{list-style-type:none}ul.lst-kix_8r7ty3cdanh8-0{list-style-type:none}ul.lst-kix_8r7ty3cdanh8-3{list-style-type:none}ul.lst-kix_8r7ty3cdanh8-2{list-style-type:none}ul.lst-kix_8r7ty3cdanh8-5{list-style-type:none}ul.lst-kix_8r7ty3cdanh8-4{list-style-type:none}ul.lst-kix_8r7ty3cdanh8-7{list-style-type:none}ul.lst-kix_8r7ty3cdanh8-6{list-style-type:none}ul.lst-kix_8r7ty3cdanh8-8{list-style-type:none}.lst-kix_uv263b97act8-5>li:before{content:"\0025a0  "}.lst-kix_uv263b97act8-6>li:before{content:"\0025cf  "}.lst-kix_uv263b97act8-4>li:before{content:"\0025cb  "}.lst-kix_uv263b97act8-8>li:before{content:"\0025a0  "}.lst-kix_uv263b97act8-1>li:before{content:"\0025cb  "}.lst-kix_uv263b97act8-2>li:before{content:"\0025a0  "}.lst-kix_uv263b97act8-3>li:before{content:"\0025cf  "}.lst-kix_uv263b97act8-7>li:before{content:"\0025cb  "}ol{margin:0;padding:0}table td,table th{padding:0}.c57{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;background-color:#d9d9d9;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c12{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#434343;border-top-width:1pt;border-right-width:1pt;border-left-color:#434343;vertical-align:top;border-right-color:#434343;border-left-width:1pt;border-top-style:solid;background-color:#d9d9d9;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#434343;border-bottom-style:solid}.c48{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;background-color:#d9d9d9;border-left-style:solid;border-bottom-width:1pt;width:329.2pt;border-top-color:#000000;border-bottom-style:solid}.c37{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:middle;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:39pt;border-top-color:#000000;border-bottom-style:solid}.c46{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:138.8pt;border-top-color:#000000;border-bottom-style:solid}.c51{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:329.2pt;border-top-color:#000000;border-bottom-style:solid}.c39{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:103.5pt;border-top-color:#000000;border-bottom-style:solid}.c34{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:73.5pt;border-top-color:#000000;border-bottom-style:solid}.c26{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:138.8pt;border-top-color:#000000;border-bottom-style:solid}.c62{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:329.2pt;border-top-color:#000000;border-bottom-style:solid}.c45{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:277.5pt;border-top-color:#000000;border-bottom-style:solid}.c3{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:117pt;border-top-color:#000000;border-bottom-style:solid}.c20{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:329.2pt;border-top-color:#000000;border-bottom-style:solid}.c28{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:429pt;border-top-color:#000000;border-bottom-style:solid}.c66{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:364.5pt;border-top-color:#000000;border-bottom-style:solid}.c29{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:138.8pt;border-top-color:#000000;border-bottom-style:solid}.c78{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:138.8pt;border-top-color:#000000;border-bottom-style:solid}.c27{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:329.2pt;border-top-color:#000000;border-bottom-style:solid}.c70{border-right-style:solid;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:234pt;border-top-color:#000000;border-bottom-style:solid}.c60{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:27pt}.c10{margin-left:-0.8pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c0{page-break-after:avoid;orphans:2;widows:2;text-align:center}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:justify}.c36{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:center}.c17{border-spacing:0;border-collapse:collapse;margin-right:auto}.c44{font-weight:bold;text-decoration:none;vertical-align:baseline;font-style:normal}.c73{margin-left:-0.8pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15}.c13{font-weight:normal;text-decoration:none;vertical-align:baseline;font-style:normal}.c31{margin-left:auto;border-spacing:0;border-collapse:collapse;margin-right:auto}.c15{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c30{color:#000000;font-size:9pt;font-family:"Droid Sans"}.c22{font-size:9pt;font-family:"Consolas";color:#666600}.c41{color:#000000;font-size:11pt;font-family:"Droid Sans"}.c6{font-size:9pt;font-family:"Consolas";color:#000000}.c50{color:#000000;font-size:24pt;font-family:"Droid Sans"}.c59{color:#000000;font-size:10pt;font-family:"Courier New"}.c4{font-size:9pt;font-family:"Courier New";color:#000000}.c79{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c18{font-size:9pt;font-family:"Courier New";color:#000088}.c2{font-size:9pt;font-family:"Courier New";color:#666600}.c43{color:#000000;font-size:11pt;font-family:"Courier New"}.c21{font-size:9pt;font-family:"Courier New";color:#660066}.c23{font-size:9pt;font-family:"Courier New"}.c32{font-size:9pt;font-weight:bold}.c19{color:#1155cc;text-decoration:underline}.c67{font-size:9pt;font-family:"Consolas"}.c42{margin-left:36pt;padding-left:0pt}.c61{padding:0;margin:0}.c9{orphans:2;widows:2}.c35{color:inherit;text-decoration:inherit}.c47{font-weight:bold}.c69{margin-right:36pt}.c54{color:#880000}.c71{text-align:right}.c80{font-family:"Courier New"}.c75{height:24pt}.c11{margin-left:54pt}.c38{page-break-after:avoid}.c58{background-color:#d9d9d9}.c53{margin-left:-0.7pt}.c68{margin-right:18pt}.c16{text-align:justify}.c55{height:36pt}.c40{color:#008800}.c74{height:20pt}.c82{font-size:16pt}.c72{text-align:left}.c56{margin-left:22.5pt}.c25{margin-left:27pt}.c65{height:16pt}.c76{color:#660066}.c64{font-size:14pt}.c24{margin-left:18pt}.c63{color:#006666}.c14{height:0pt}.c52{margin-left:36pt}.c8{height:11pt}.c49{text-align:center}.c77{height:19pt}.c81{text-indent:-0.7pt}.c1{font-style:italic}.c33{height:21pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Droid Sans";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}li{color:#000000;font-size:11pt;font-family:"Droid Sans"}p{margin:0;color:#000000;font-size:11pt;font-family:"Droid Sans"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Droid Sans";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Droid Sans";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Droid Sans";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Droid Sans";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Droid Sans";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Droid Sans";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:justify}</style></head><body class="c79"><div><p class="c9 c71 c8"><span></span></p><p class="c9 c8 c71"><span></span></p><p class="c9 c71 c8"><span></span></p><p class="c9 c71"><span class="c47">Hermes User Guide</span></p></div><p class="c0 c8 title" id="h.cdq8rk3g8o44"><span></span></p><p class="c0 c8 title" id="h.kbgjny6nt6p0"><span></span></p><p class="c0 c8 title" id="h.qv4aktlzk2sc"><span></span></p><p class="c0 title" id="h.peza71lx86oe"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 369.00px; height: 105.00px;"><img alt="hermes.png" src="images/image01.png" style="width: 369.00px; height: 105.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h2 class="c9 c38 c65" id="h.7xhwllbsvz8x"><span></span></h2><p class="c0 c8 title" id="h.uc6sdsaftzlw"><span></span></p><p class="c0 c8 title" id="h.ywg6g4o4mm8k"><span></span></p><p class="c0 title" id="h.4x6i0zlvkusv"><span>User Guide</span></p><p class="c9 c49"><span class="c47 c64">Version 0.3</span></p><p class="c9 c49"><span class="c47 c64">David B. Bracewell</span></p><p class="c9 c49"><span class="c47 c64">Copyright &copy; 2016</span></p><p class="c9 c8"><span class="c64"></span></p><h2 class="c9 c38 c65" id="h.3osqtuogr77w"><span></span></h2><hr style="page-break-before:always;display:none;"><h2 class="c9 c38 c65" id="h.ga6tuid0n00e"><span></span></h2><p class="c0 title" id="h.xiur859cr1gn"><span>Table of Contents</span></p><p class="c9 c24"><span class="c19"><a class="c35" href="#h.orh2jsm3yysz">Overview</a></span></p><p class="c9 c24"><span class="c19"><a class="c35" href="#h.e9fld0rs8oct">Documents and Corpora</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.f276ypes7b0w">Creating Documents</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.jdijpbo07dr5">Reading and Writing Documents</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.qemkg4dihnxo">Working with Documents</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.bi1tv49kqs3y">Creating Corpora</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.hdru8r2h48sr">Corpus Formats</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.byprvozcc69r">Delimiter Separated Value (DSV) Format</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.zg4rcjb1m9pf">CoNLL Format</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.cchr0esdcq2o">Writing Corpora</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.jb6xb6g9fcsc">Working with Corpora</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.lg8fekg7n0iq">Annotation</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.e1398oqczo4">Filtering and Querying</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.mnmfrtv1j8ne">Frequency Analysis</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.x0uljfvxdfon">Extracting N-Grams</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.fpsg8ck0p5ix">Sampling</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.o28ivlpf4w25">Grouping</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.fznfvc8wld62">Machine Learning</a></span></p><p class="c9 c24"><span class="c19"><a class="c35" href="#h.kwb30bl9y5fh">Annotations</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.kcckxcil65m2">Annotation Types</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.ufc86mn708m9">Core Annotation Types</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.m20hmpx2jr34">Token</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.1wom5lbmm526">Sentence</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.x7xyxi7u4imd">Phrase Chunk</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.w2icg9bg40rk">Entity</a></span></p><p class="c9 c11"><span class="c19"><a class="c35" href="#h.7n20nzzhmfpe">Word Sense</a></span></p><p class="c9 c24"><span class="c19"><a class="c35" href="#h.l6deiq7s7q00">Attributes</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.in9w9kvxct1h">Attribute Types</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.7181v2o14wjz">Attribute Value Codecs</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.335imo78aqzi">Tag Attributes</a></span></p><p class="c9 c24"><span class="c19"><a class="c35" href="#h.hywdg1ocij94">Relations</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.fozs7588yg96">Relation Types</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.m2gyum6xzqq6">Dependency Relations</a></span></p><p class="c9 c24"><span class="c19"><a class="c35" href="#h.ygs42yp7c45a">Annotators</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.x83i9ie16mf3">Sentence Level Annotators</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.9c0rsqit60of">Sub Type Annotators</a></span></p><p class="c9 c24"><span class="c19"><a class="c35" href="#h.yrbtudkfm0bb">Information Extraction</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.v7uzt4um6la7">Lexicon Matching</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.v7uzt4um6la7">Token-based Regular Expressions</a></span></p><p class="c9 c52"><span class="c19"><a class="c35" href="#h.v7uzt4um6la7">Caduceus</a></span></p><h1 class="c9 c38 c16" id="h.orh2jsm3yysz"><span>Overview</span></h1><p class="c9 c16"><span>Hermes is a Natural Language Processing framework for Java inspired by the</span><span><a class="c35" href="https://www.google.com/url?q=http://cs.nyu.edu/cs/faculty/grishman/tipster.html&amp;sa=D&amp;ust=1465768762485000&amp;usg=AFQjCNFjdy3St3WsZK_SSfSQ1x3zlPT2VQ">&nbsp;</a></span><span class="c19"><a class="c35" href="https://www.google.com/url?q=http://cs.nyu.edu/cs/faculty/grishman/tipster.html&amp;sa=D&amp;ust=1465768762486000&amp;usg=AFQjCNFZs_hDXqmlbRHSs9ONSqvyWiJ1Ow">Tipster Architecture</a></span><span>&nbsp; and licensed using the </span><span class="c19"><a class="c35" href="https://www.google.com/url?q=https://github.com/dbracewell/hermes/wiki/LICENSE&amp;sa=D&amp;ust=1465768762486000&amp;usg=AFQjCNFRyjD19Msl1z8Fys2oP-cDlikIlQ">Apache License, Version 2.0</a></span><span>&nbsp;making it free for all uses</span><span>. The goal of Hermes is to simplify the development and use of NLP technologies by providing easy access to and construction of linguistic annotations on documents using multiple cores or multiple machines (using</span><span><a class="c35" href="https://www.google.com/url?q=http://spark.apache.org/&amp;sa=D&amp;ust=1465768762487000&amp;usg=AFQjCNGcgr68z2nwSD4o5-3MxeVsLbjinw">&nbsp;</a></span><span class="c19"><a class="c35" href="https://www.google.com/url?q=http://spark.apache.org/&amp;sa=D&amp;ust=1465768762488000&amp;usg=AFQjCNH6i_p0JDniUrXBER_qjAfoV-aBnQ">Apache Spark</a></span><span>). &nbsp;Conceptually, Hermes models corpora which are made up of one or more documents which in turn contain annotations, attributes, and relations between annotations. A visualization of these layers is shown below.</span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 178.96px;"><img alt="" src="images/image02.png" style="width: 624.00px; height: 178.96px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9 c16 c8"><span class="c82"></span></p><p class="c9 c16"><span>All text-based objects extend from </span><span class="c1">HString</span><span>&nbsp;(short for Hermes String) making them treatable as character sequences (by extending </span><span class="c1">CharSequence</span><span>) while also providing access to annotations (by extending </span><span class="c1">AnnotatedObject</span><span>), attributes (by extending </span><span class="c1">AttributedObject</span><span>), relations (by extending </span><span class="c1">RelationalObject</span><span>), and the owning document. In addition to normal string operations, </span><span class="c1">HString</span><span>s provide methods for:</span></p><p class="c9 c16 c8"><span></span></p><ul class="c61 lst-kix_t7afhzt26ilu-0 start"><li class="c9 c16 c42"><span>Obtaining its character offsets in the document, i.e. span.</span></li><li class="c42 c9 c16"><span>Determining the spatial relation (e.g. overlaps, encloses) with other spans.</span></li><li class="c42 c9 c16"><span>Generating annotation and character level n-grams.</span></li><li class="c42 c9 c16"><span>String-based pattern matching.</span></li><li class="c42 c9 c16"><span>Conversion to labeled data and sequences for machine learning giving an attribute or function to determine the label.</span></li><li class="c42 c9 c16"><span>Convenience methods for retrieving the part-of-speech and the lemmatized or stemmed version of the content.</span></li></ul><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>Special versions of HString representing an empty text object and a text object not belonging to a document, i.e. fragment, are used in order to avoid returning null values. For more information on the methods available to HStrings see the javadoc for HString.</span></p><h1 class="c9 c38 c16" id="h.e9fld0rs8oct"><span>Documents and Corpora</span></h1><p class="c9 c16"><span>Hermes provides methods to work on a single document or a collection of documents, i.e. a corpus. &nbsp;A </span><span class="c1">Document</span><span>&nbsp;is represented as a text (</span><span class="c1">HString</span><span>) and its associated attributes (metadata), annotations (represented as a span of characters and associated attributes), and relations between annotations. Corpora represent a collection of documents which are stored in memory on a single machine or distributed using Spark or streamed from disk.</span></p><h2 class="c9 c38 c16" id="h.f276ypes7b0w"><span>Creating Documents</span></h2><p class="c9 c16"><span>Documents are created using the </span><span class="c1">DocumentFactory</span><span>&nbsp;class which performs preprocessing (e.g normalizing whitespace and unicode) using zero or more </span><span class="c1">TextNormalizer </span><span>instances</span><span>.</span></p><p class="c9 c16 c8"><span></span></p><a id="t.11317608df3150fcf1d50da94de3a2bae94f1510"></a><a id="t.0"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c73 c9 c68 c72"><span class="c21">Document</span><span class="c4">&nbsp;document </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c21">DocumentFactory</span><span class="c2">.</span><span class="c4">getInstance</span><span class="c2">().</span><span class="c4">create</span><span class="c2">(</span><span class="c23 c40">&quot;...My Text Goes Here...&quot;</span><span class="c2">);</span></p></td></tr></tbody></table><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>The default </span><span class="c1">DocumentFactory </span><span>instance has its default language and TextNormalizers defined via configuration using the </span><span class="c1">hermes.preprocessing</span><span>&nbsp;and </span><span class="c1">hermes.DefaultLanguage</span><span>&nbsp;settings. By Default, English is the default language and whitespace and unicode normalization is performed during preprocessing. For convenience a document can also be created using static methods on the document class, which will use the default </span><span class="c1">DocumentFactory</span><span>, i.e. the result of </span><span class="c1">getInstance()</span><span>.</span></p><p class="c9 c68 c56 c8"><span class="c67 c76 c1"></span></p><a id="t.81d2a82c350422e40dd6de4035f47b71fe3fc489"></a><a id="t.1"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c10 c9 c68"><span class="c21">Document</span><span class="c23">&nbsp;document </span><span class="c2">=</span><span class="c23">&nbsp;</span><span class="c21">Document</span><span class="c2">.</span><span class="c23">create</span><span class="c2">(</span><span class="c23 c40">&quot;...My Text Goes Here...&quot;</span><span class="c2">);</span></p></td></tr></tbody></table><p class="c9 c68 c56 c8"><span class="c67 c1 c76"></span></p><p class="c9 c16"><span>Different </span><span class="c1">create</span><span>&nbsp;methods on the DocumentFactory and Document facilitate assigning a document id, language, and document level attributes. All Hermes documents have an id assigned. When an id is not explicitly given an id is generated using Java&rsquo;s built-in UUID generator. While not enforced, document ids should be unique within a corpus. The </span><span class="c1">DocumentFactory</span><span>&nbsp;class also allows for constructing a document from an already tokenized source and for creating &ldquo;raw&rdquo; documents that bypass preprocessing. This is particularly useful when constructing documents from already analyzed 3rd party corpora. &nbsp;</span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>Custom document factories can be created using a builder object obtained by calling the </span><span class="c1">builder()</span><span>&nbsp;method on the </span><span class="c1">DocumentFactory</span><span>&nbsp;class</span><span>. This custom document factory can then be used to create new documents. </span></p><p class="c9 c16 c8"><span></span></p><a id="t.16cdb1a4132d18fa6a6c13e6f654c9eb9f325ada"></a><a id="t.2"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c10 c9"><span class="c21">DocumentFactory</span><span class="c2">.</span><span class="c4">builder</span><span class="c2">().</span><span class="c4">defaultLanguage</span><span class="c2">(</span><span class="c21">Language</span><span class="c2">.</span><span class="c13 c4">CHINESE)</span></p><p class="c10 c9"><span class="c4">&nbsp; </span><span class="c2">.</span><span class="c4">add</span><span class="c2">(</span><span class="c18">new</span><span class="c4">&nbsp;</span><span class="c21">TraditionalToSimplified</span><span class="c13 c2">())</span></p><p class="c10 c9"><span class="c2">&nbsp; .</span><span class="c4">build</span><span class="c2">();</span></p></td></tr></tbody></table><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>In the above given example, a document factory is constructed that has Chinese as its default language, which will be assigned when a language is not explicitly given when the document is constructed, and a preprocessor that converts traditional Chinese characters to simplified Chinese characters. &nbsp;Custom text normalizers can be created by extending the </span><span class="c1">TextNormalizer</span><span>&nbsp;class. Minimally, the custom normalizer needs to implement the </span><span class="c1">performNormalization(String input, Language language)</span><span>&nbsp;method. A normalizer will not be applied when its &ldquo;apply&rdquo; config value is set to false (</span><span class="c1">fully.qualified.name.apply=false</span><span>), this can be set on a per language basis using a language specific config setting (</span><span class="c1">fully.qualified.name.LANGUAGE.apply=false</span><span>).</span></p><h2 class="c9 c38 c16" id="h.jdijpbo07dr5"><span>Reading and Writing Documents</span></h2><p class="c9 c16"><span>Documents provide methods for reading and writing to and from a structured format (xml, json, etc.) as implemented in the Mango project. &nbsp;The </span><span class="c1">Document</span><span>&nbsp;class has a static </span><span class="c1">read</span><span>&nbsp;method which takes a </span><span class="c1">StructuredFormat</span><span>&nbsp;instance specifying the format to read from (Json in the example below) and a </span><span class="c1">Resource</span><span>&nbsp;from which the document will be read. More information on structured formats and resources can be found in the documentation for the Mango project.</span></p><p class="c9 c8 c25"><span class="c1"></span></p><a id="t.ca186723c70acc786f431580df463b0274647b47"></a><a id="t.3"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c10 c9"><span class="c21">Document</span><span class="c2">.</span><span class="c4">read</span><span class="c2">(</span><span class="c21">StructuredFormat</span><span class="c2">.</span><span class="c4">JSON</span><span class="c2">,</span></p><p class="c10 c9"><span class="c23">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c21">Resources</span><span class="c2">.</span><span class="c18">from</span><span class="c2">(</span><span class="c23 c40">&quot;/data/my_document.json&quot;</span><span class="c2">));</span></p></td></tr></tbody></table><p class="c9 c25 c8"><span class="c1"></span></p><p class="c9 c16"><span>Writing a document is similar to reading. Given the document object (</span><span class="c1">doc</span><span>&nbsp;in the example below), we call the </span><span class="c1">write</span><span>&nbsp;method for the structured format to write in and the resource to which will be written. </span></p><p class="c9 c56 c8"><span class="c1"></span></p><a id="t.85a06e8443be3af753aa222d5cba08993cebf18d"></a><a id="t.4"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c9 c72 c73"><span class="c21">Document</span><span class="c4">&nbsp;doc </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c21">Document</span><span class="c2">.</span><span class="c4">create</span><span class="c2">(</span><span class="c23 c40">&quot;... My Text goes here ...&quot;</span><span class="c2">);</span><span class="c4"><br>doc</span><span class="c2">.</span><span class="c4">write</span><span class="c2">(</span><span class="c21">StructuredFormat</span><span class="c2">.</span><span class="c4">JSON</span><span class="c2">,</span></p><p class="c73 c9 c72"><span class="c23">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c21">Resources</span><span class="c2">.</span><span class="c18">from</span><span class="c2">(</span><span class="c23 c40">&quot;/data/my_document.json&quot;</span><span class="c2">));</span></p></td></tr></tbody></table><p class="c9"><span class="c1"><br></span><span>Json is the preferred format for Hermes documents and as such convenience methods exists for reading and writing from Json. In particular, there is a static method </span><span class="c1">fromJson</span><span>&nbsp;which takes a string in Json format and returns a </span><span class="c1">Document </span><span>object and their is a </span><span class="c1">toJson</span><span>&nbsp;method to convert the document into a Json encoded string.</span></p><p class="c9 c16 c56 c8"><span class="c1"></span></p><a id="t.277ee4ccb921d7f864cf9d6e0d46b9c1f35b4cd8"></a><a id="t.5"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c10 c9"><span class="c23 c54">//Create a document from a Json string</span></p><p class="c10 c9"><span class="c21">Document</span><span class="c2">.</span><span class="c4">fromJson</span><span class="c2">(</span><span class="c23 c40">&quot;...json...&quot;</span><span class="c2">);</span></p><p class="c10 c9"><span class="c23 c54">//Write a document to a string encoded using Json</span></p><p class="c10 c9"><span class="c21">String </span><span class="c23">json = </span><span class="c4">doc</span><span class="c2">.</span><span class="c4">toJson</span><span class="c2">();</span></p></td></tr></tbody></table><p class="c9 c16 c8 c56"><span class="c1"></span></p><p class="c9"><span>The </span><span class="c1">toJson</span><span>&nbsp;methods returns a &ldquo;one line&rdquo; json, which is useful in distributed environments. An example of such a json is given below.</span></p><p class="c9 c8"><span></span></p><a id="t.c2af483ae6fbfde5602ad7da5d5598cfa757bace"></a><a id="t.6"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c10 c9"><span class="c2">{</span><span class="c23 c40">&quot;id&quot;</span><span class="c2">:</span><span class="c23 c40">&quot;id&quot;</span><span class="c2">,</span><span class="c23 c40">&quot;content&quot;</span><span class="c2">:</span><span class="c23 c40">&quot;content&quot;</span><span class="c2">,</span><span class="c23 c40">&quot;attributes&quot;</span><span class="c2">:{</span><span class="c23 c40">&quot;LANGUAGE&quot;</span><span class="c2">:</span><span class="c23 c40">&quot;ENGLISH&quot;</span><span class="c2">}}</span></p></td></tr></tbody></table><h2 class="c9 c38 c16" id="h.qemkg4dihnxo"><span>Working with Documents</span></h2><p class="c9 c16"><span>Annotations, explained in more detail in the annotation section, are spans of text on the document which have their own associated set of attributes and relations. Annotations are added to a document using a Pipeline. The pipeline defines the type of annotations, attributes, and relations that will be added to the document. The example below will add tokens and sentences to the document.</span></p><p class="c9 c16 c8"><span class="c1"></span></p><a id="t.1e15aa23c993ab7c44547b17d2a03708d4409896"></a><a id="t.7"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c10 c9"><span class="c21">Pipeline</span><span class="c2">.</span><span class="c4">process</span><span class="c2">(</span><span class="c4">document</span><span class="c2">,</span><span class="c4">&nbsp;</span><span class="c21">Types</span><span class="c2">.</span><span class="c4">TOKEN</span><span class="c2">,</span><span class="c4">&nbsp;</span><span class="c21">Types</span><span class="c2">.</span><span class="c4">SENTENCE</span><span class="c2">);</span></p></td></tr></tbody></table><p class="c9 c16 c8"><span class="c1"></span></p><p class="c9 c16"><span>Ad-hoc annotations are easily added using one of the </span><span class="c1">createAnnotation</span><span>&nbsp;methods on the document. The first step is to define your </span><span class="c1">AnnotationType</span><span>, annotation types are described in more detail in the annotation section.</span></p><p class="c9 c8"><span></span></p><a id="t.505e519df35080ab61c3e70afa339ceb6fc584f4"></a><a id="t.8"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c5"><span class="c21">AnnotationType</span><span class="c4">&nbsp;animalMention </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c21">Types</span><span class="c2">.</span><span class="c4">type</span><span class="c2">(</span><span class="c23 c40">&quot;ANIMAL_MENTION&quot;</span><span class="c2">);</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9 c16"><span>Now, let&#39;s identify animal mentions using a simple regular expression. Since Document extends HString we have save time saving methods for dealing with the textual content. Namely, we can easily get easily get a Java regex </span><span class="c1">Matcher</span><span>&nbsp;for the content of the document by:</span></p><p class="c9 c8"><span></span></p><a id="t.5c47a1513ea03a6877b251cdc1765c36b5e4c892"></a><a id="t.9"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c15 c9 c53"><span class="c21">Matcher</span><span class="c4">&nbsp;matcher </span><span class="c2">=</span><span class="c4">&nbsp;document</span><span class="c2">.</span><span class="c4">matcher</span><span class="c2">(</span><span class="c23 c40">&quot;\\b(fox|dog)\\b&quot;</span><span class="c2">);</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9 c16"><span>With the matcher, we can iterate over the matches and create new annotations as follows:</span></p><p class="c9 c8 c72"><span></span></p><a id="t.6c2e5f1a653be1b597fead60ab4a809b60318d57"></a><a id="t.10"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c5 c9 c69 c53"><span class="c18">while</span><span class="c4">&nbsp;</span><span class="c2">(</span><span class="c4">matcher</span><span class="c2">.</span><span class="c4">find</span><span class="c2">())</span><span class="c4">&nbsp;</span><span class="c13 c2">{ </span></p><p class="c5 c9 c69 c53"><span class="c23">&nbsp; &nbsp;</span><span class="c23">d</span><span class="c4">ocument</span><span class="c2">.</span><span class="c4">createAnnotation</span><span class="c2">(</span><span class="c4">animalMention</span><span class="c13 c2">,</span></p><p class="c5 c9 c69 c53"><span class="c23">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c4">matcher</span><span class="c2">.</span><span class="c4">start</span><span class="c13 c2">(),</span></p><p class="c5 c9 c69 c53"><span class="c23">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c4">matcher</span><span class="c2">.</span><span class="c18">end</span><span class="c2">()); </span></p><p class="c5 c9 c53 c69"><span class="c4">}</span></p></td></tr></tbody></table><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>More complicated annotation types would also provide attributes, for example entity type, word sense, etc.</span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>Once annotations have been added to a document they can be retrieved using the </span><span class="c1">get(AnnotationType)</span><span>&nbsp;method. </span></p><p class="c9 c16 c8"><span></span></p><a id="t.008b4add1b4f37cada59d1f3a717b2c917805c70"></a><a id="t.11"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c9 c53 c60"><span class="c4">document</span><span class="c2">.</span><span class="c18">get</span><span class="c2">(</span><span class="c4">animalMention</span><span class="c2">)</span></p><p class="c60 c9 c53"><span class="c2">.</span><span class="c4">forEach</span><span class="c2">(</span><span class="c4">a </span><span class="c2">-&gt;</span><span class="c13 c4">&nbsp;</span></p><p class="c60 c9 c53"><span class="c21">&nbsp; &nbsp; System</span><span class="c2">.</span><span class="c18">out</span><span class="c2">.</span><span class="c4">println</span><span class="c2">(</span><span class="c4">a </span><span class="c2">+</span><span class="c4">&nbsp;</span><span class="c23 c40">&quot;[&quot; </span><span class="c2">+ </span><span class="c4">a</span><span class="c2">.</span><span class="c4">start</span><span class="c2">() + </span><span class="c23 c40">&quot;, &quot;</span><span class="c4">&nbsp;</span><span class="c2">+</span><span class="c4">&nbsp;a</span><span class="c2">.</span><span class="c18">end</span><span class="c2">()</span><span class="c4">&nbsp;</span><span class="c2">+</span><span class="c4">&nbsp;</span><span class="c23 c40">&quot;]&quot;</span><span class="c2">));</span></p></td></tr></tbody></table><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>In addition, convenience methods exist for retrieving tokens, </span><span class="c1">tokens()</span><span>, and sentences, </span><span class="c1">sentences()</span><span>. </span></p><p class="c9 c16 c8"><span></span></p><a id="t.d40ec40ed55c980f0febda6f3db5dcab5ef319cd"></a><a id="t.12"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c15 c9 c81"><span class="c4">document</span><span class="c2">.</span><span class="c4">sentences</span><span class="c2">().</span><span class="c4">forEach</span><span class="c2">(</span><span class="c21">System</span><span class="c2">.</span><span class="c18">out</span><span class="c2">::</span><span class="c4">println</span><span class="c2">);</span></p></td></tr></tbody></table><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>A document stores its associated annotations using an </span><span class="c1">AnnotationSet</span><span>. The default implementation uses an interval tree backed by a red-black tree, which provides O(n) storage and average O(log n) for search, insert, and delete operations. </span></p><h2 class="c9 c38 c16" id="h.bi1tv49kqs3y"><span>Creating Corpora</span></h2><p class="c9 c16"><span>Corpora represent a collection of documents over which analysis is typically performed. Corpora are created </span><span>using a builder pattern as demonstrated below. </span></p><p class="c9 c16 c8"><span></span></p><a id="t.aa66e767d18930ed0550ea812b65588165acac6f"></a><a id="t.13"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c5"><span class="c21">Corpus</span><span class="c2">.</span><span class="c4">builder</span><span class="c2">()</span><span class="c4"><br> &nbsp;</span><span class="c2">.</span><span class="c4">format</span><span class="c2">(</span><span class="c23 c40">&quot;TEXT&quot;</span><span class="c2">)</span><span class="c4"><br></span><span class="c23 c54">// &nbsp; &nbsp; &nbsp;.distributed() -- Distributed corpus (Apache Spark)</span><span class="c4"><br></span><span class="c23 c54">// &nbsp; &nbsp; &nbsp;.offHeap() &nbsp; &nbsp;-- Stream corpus from disk (default)</span><span class="c4"><br></span><span class="c13 c23 c54">// &nbsp; &nbsp; &nbsp;.inMemory() -- Store corpus in-memory</span></p><p class="c5"><span class="c4">&nbsp; </span><span class="c2">.</span><span class="c4">source</span><span class="c2">(</span><span class="c21">Resources</span><span class="c2">.</span><span class="c18">from</span><span class="c2">(</span><span class="c23 c40">&quot;file&quot;</span><span class="c2">))</span><span class="c4"><br> &nbsp;</span><span class="c2">.</span><span class="c4">build</span><span class="c2">();</span></p></td></tr></tbody></table><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>A </span><span class="c1">CorpusBuilder</span><span>&nbsp;is obtained by calling the </span><span class="c1">builder()</span><span>&nbsp;method on the </span><span class="c1">Corpus</span><span>&nbsp;class. There are &nbsp;three main pieces of information that needs to be provided to create a corpus: 1) where it is located, 2) what format it is in, and 3) how it should be accessed. </span></p><p class="c9 c16 c8"><span></span></p><p class="c9"><span>The location of where the corpus is stored is specified using the source method on the builder. The method takes a Resource object (see the Mango project), which allows for the corpus to be stored in a variety of places. The format of the corpus defines how to read and write the corpora. &nbsp;The format is specified using the format method (see the next subsection for more details about corpus formats). Hermes defines three ways in which a corpus can be accessed. The first is in-memory, specified using the </span><span class="c1">inMemory</span><span>&nbsp;method on the builder, which will read the entire corpus into memory. Care should be taken as large corpora may not fully fit into memory. &nbsp;The second mode of access is by streaming the corpus from its source, which is referred to as </span><span class="c1">offHeap</span><span>&nbsp;as the entire corpus is never fully loaded into memory. Operations over off-heap corpora will be slower and depending on the operations (e.g. annotation) may require extra temporary storage for storing intermediate results. The final way to access a corpus is in a distributed fashion using the Apache Spark framework. This is done by calling the distributed method. Once distributed operations over the corpus will be executed as Apache Spark jobs.</span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>In addition, convenience methods exist to create corpora from a </span><span class="c1">Collection</span><span>, </span><span class="c1">Iterable</span><span>, </span><span class="c1">Stream</span><span>, </span><span class="c1">MStream</span><span>&nbsp;(Mango Stream), or variable number of Documents. The access methodology of the created corpus depends on the input. The mapping is as follows:</span></p><p class="c9 c16 c8"><span></span></p><ul class="c61 lst-kix_c1iujowgdv8g-0 start"><li class="c42 c9 c16"><span>Collection &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10142; In-Memory</span></li><li class="c42 c9 c16"><span>Iterable &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10142; In-Memory</span></li><li class="c42 c9 c16"><span>Stream&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10142; In-Memory (Unless the underlying stream is file based)</span></li><li class="c42 c9 c16"><span>MStream&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10142; In-Memory (JavaStream) or Distributed (SparkStream)</span></li></ul><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>Finally, a new corpus can be created by unioning two corpora. The two corpora will act as one, but no data will be moved or reorganized.</span></p><h2 class="c9 c38 c16" id="h.hdru8r2h48sr"><span>Corpus Formats</span></h2><p class="c9 c16"><span>Corpora are found in many formats, e.g. CONLL, csv, plain text, etc. Hermes provides support for reading and writing corpora in these various formats through implementations of the </span><span class="c1">CorpusFormat </span><span>interface. An implementation defines the common extension (e.g. &ldquo;txt&rdquo; or &ldquo;conll&rdquo;), the name of the format (e.g. &ldquo;CONLL&rdquo;), and methods for reading and writing the format. Corpus formats are accessed via the </span><span class="c1">CorpusFormats</span><span>&nbsp;class which has a static method for </span><span>retrieving a format by its name (Note: names are normalized allowing for retrieval regardless of the case). Corpus formats are statically loaded using the java service provider interface. </span></p><p class="c9 c16 c8"><span></span></p><a id="t.49215f4614be4f276d7d17d736cdb42b5bd9e1d4"></a><a id="t.14"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c7"><span class="c23 c54">//All three calls will result in the same CorpusFormat</span></p><p class="c5"><span class="c21">CorpusFormat</span><span class="c4">&nbsp;oneJsonPerFile1 </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c21">CorpusFormats</span><span class="c2">.</span><span class="c4">forName</span><span class="c2">(</span><span class="c23 c40">&quot;JSON&quot;</span><span class="c2">);</span></p><p class="c7"><span class="c21">CorpusFormat</span><span class="c4">&nbsp;oneJsonPerFile2 </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c21">CorpusFormats</span><span class="c2">.</span><span class="c4">forName</span><span class="c2">(</span><span class="c23 c40">&quot;jSon&quot;</span><span class="c2">);</span><span class="c13 c4">&nbsp;</span></p><p class="c7"><span class="c21">CorpusFormat</span><span class="c4">&nbsp;oneJsonPerFile3 </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c21">CorpusFormats</span><span class="c2">.</span><span class="c4">forName</span><span class="c2">(</span><span class="c23 c40">&quot; jSoN &quot;</span><span class="c2">);</span><span class="c13 c4">&nbsp;</span></p><p class="c7"><span class="c23 c54">//Common formats are predefined</span></p><p class="c5"><span class="c21">CorpusFormat</span><span class="c23">&nbsp;</span><span class="c4">oneJsonPerFile4 </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c21">C</span><span class="c21">orpusFormats</span><span class="c2">.</span><span class="c4">forName</span><span class="c2">(</span><span class="c21">CorpusFormats</span><span class="c2">.</span><span class="c4">JSON</span><span class="c2">);</span></p></td></tr></tbody></table><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>Additionally, there is a special </span><span class="c1">OnePerLineFormat</span><span>, which converts formats into one document per line. This is useful when working in a distributed environment. A format can be specified as using &ldquo;one per line&rdquo; by appending &ldquo;_opl&rdquo; to its name, e.g. &ldquo;json&rdquo; would become &ldquo;json_opl&rdquo;. </span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>Currently, Hermes provides formats for Json and Xml (output of the write method of </span><span class="c1">Document</span><span>), CoNLL, tsv, csv, and plain text. &nbsp;The Json and Xml formats are the only ones to support serialization of all annotations, attributes, and relations on a document. </span></p><h3 class="c9 c38 c16" id="h.byprvozcc69r"><span>Delimiter Separated Value (DSV) Format </span></h3><p class="c9 c16"><span>DSV formatted corpora contain multiple fields (e.g. document id, content, and document level attributes) separated by some delimiter. Common delimiters include the comma (CSV) and tab (TSV), which relate to the </span><span class="c1">CSVCorpus</span><span>&nbsp;and </span><span class="c1">TSVCorpus</span><span>&nbsp;implementations respectively. DSV implementations extend the abstract </span><span class="c1">DSVFormat</span><span>&nbsp;class. Implementations only need to specify the config prefix, the delimiter, and the name. </span></p><p class="c9 c16 c8"><span></span></p><p class="c9"><span>The DSV format defines the following config parameters (&ldquo;prefix&rdquo; is defined by the implementation, e.g. CSVCorpus for CSV and TSVCorpus for TSV):</span></p><p class="c9 c16 c8"><span></span></p><a id="t.d6c332f586d0e0f9728fe15f87f55013e43e68c6"></a><a id="t.15"></a><table class="c31"><tbody><tr class="c14"><td class="c3 c58" colspan="1" rowspan="1"><p class="c36"><span class="c44 c41">Property</span></p></td><td class="c34 c58" colspan="1" rowspan="1"><p class="c36"><span class="c44 c41">Default Value</span></p></td><td class="c45 c58" colspan="1" rowspan="1"><p class="c36"><span class="c41 c44">Description</span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c7"><span class="c13 c41">prefix.idField</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">ID</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">The name of the field containing the document id.</span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">prefix.contentField</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">CONTENT</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">The name of the field containing the document content. </span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">prefix.languageField</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">LANGUAGE</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">The name of the field containing the language of the text in the document.</span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">prefix.fields</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c5 c8"><span class="c13 c41"></span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">Names of the fields in csv format..</span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">prefix.comment</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">#</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">The character representing a comment in the DSV.</span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">prefix.hasHeader</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">false</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">True if the file has a header.</span></p></td></tr></tbody></table><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>All other fields in the file are considered document attributes. </span><span>The only field required to be present is the content field.</span></p><h3 class="c9 c38 c16" id="h.zg4rcjb1m9pf"><span>CoNLL Format</span></h3><p class="c9 c16"><span>The CoNLL (Conference on Natural Language Learning) is a columnar format that has many variations based on the different shared tasks that have been performed of the years. The Hermes CoNLL format provides a generic way of handling these variations. This is done by by associating a </span><span class="c1">FieldType</span><span>&nbsp;with each of the columns in the corpus. Currently, the following types are defined: </span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><a id="t.ef739bc37b531a4bc4ab08a38069be7fce56bf41"></a><a id="t.16"></a><table class="c17"><tbody><tr class="c14"><td class="c39 c58" colspan="1" rowspan="1"><p class="c36"><span class="c44 c41">Field Type</span></p></td><td class="c58 c66" colspan="1" rowspan="1"><p class="c36"><span class="c44 c41">Description</span></p></td></tr><tr class="c14"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">POS</span></p></td><td class="c66" colspan="1" rowspan="1"><p class="c5"><span>Processes columns with part-of-speech informati</span><span>on</span><span class="c13 c41">.</span></p></td></tr><tr class="c14"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">CHUNK</span></p></td><td class="c66" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">Processes columns for IOB style annotations for phrase chunks.</span></p></td></tr><tr class="c14"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">ENTITY</span></p></td><td class="c66" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">Processes columns for IOB style annotations for named entities.</span></p></td></tr><tr class="c14"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">WORD</span></p></td><td class="c66" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">Processes columns representing the surface form of the word.</span></p></td></tr><tr class="c14"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">IGNORE</span></p></td><td class="c66" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">No opt processor that ignores the given column.</span></p></td></tr><tr class="c14"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">INDEX</span></p></td><td class="c66" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">Processes columns associated with the index of the word.</span></p></td></tr></tbody></table><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>Types are assigned to columns through the </span><span class="c1">CONLL.fields</span><span>&nbsp;property. The value of this property is column separated with one of the field type names given in each column. Additional configuration properties include:</span></p><p class="c9 c8"><span></span></p><a id="t.bd6a2880aab0d740f1c955e2b6aaee9b4b7c30af"></a><a id="t.17"></a><table class="c31"><tbody><tr class="c14"><td class="c3 c58" colspan="1" rowspan="1"><p class="c36"><span class="c44 c41">Property</span></p></td><td class="c34 c58" colspan="1" rowspan="1"><p class="c36"><span class="c44 c41">Default Value</span></p></td><td class="c45 c58" colspan="1" rowspan="1"><p class="c36"><span class="c44 c41">Description</span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c7"><span class="c13 c41">CONLL.docPerSent</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">false</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">Each sentence in a CoNLL document becomes its own document.</span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">CONLL.fs</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">\s+</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">Regular expression used to split rows into columns.</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9 c16"><span>Documents loaded from CoNLL corpora will have the annotations and attributes completed on the document for each of the field types defined. Minimally, sentence and token annotations will be added. &nbsp;</span></p><h2 class="c9 c38 c16" id="h.cchr0esdcq2o"><span>Writing Corpora</span></h2><p class="c9 c16"><span>Writing corpora is done using the </span><span class="c1">write </span><span>method. The full write method takes the format to write the corpus in (</span><span class="c1">CorpusFormat</span><span>&nbsp;or name of the format) and the location to write the corpus (</span><span class="c1">Resource</span><span>&nbsp;or </span><span class="c1">String</span><span>). Convenience methods exist that only take the location to write the corpus and use the default corpus format of one json per line.</span></p><p class="c9 c16 c8"><span></span></p><a id="t.63d4965fe7ea7ecd2190c92e1f945720569e305f"></a><a id="t.18"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c7"><span class="c21">Corpus</span><span class="c4">&nbsp;corpus </span><span class="c2">=</span><span class="c4">&nbsp;createCorpus</span><span class="c2">();</span></p><p class="c7"><span class="c21">Resource</span><span class="c4">&nbsp;outputLocation </span><span class="c2">=</span><span class="c4">&nbsp;getOutputLocation</span><span class="c2">();</span></p><p class="c7"><span class="c18">try</span><span class="c13 c4">&nbsp;{</span></p><p class="c7"><span class="c4">&nbsp; &nbsp;corpus</span><span class="c2">.</span><span class="c4">write</span><span class="c2">(</span><span class="c4">&nbsp;</span><span class="c23">CorpusFormats.JSON_OPL</span><span class="c2">,</span><span class="c4">&nbsp;outputLocation </span><span class="c2">);</span></p><p class="c7"><span class="c2">}</span><span class="c4">&nbsp;</span><span class="c18">catch</span><span class="c2">(</span><span class="c4">&nbsp;</span><span class="c21">IOException</span><span class="c4">&nbsp;e </span><span class="c2">)</span><span class="c13 c4">&nbsp;{</span></p><p class="c7"><span class="c4">&nbsp; &nbsp;e</span><span class="c2">.</span><span class="c4">printStackTrace</span><span class="c2">();</span></p><p class="c7"><span class="c4">}</span></p></td></tr></tbody></table><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>Formats that save one document per file (e.g. Json, Text, and CoNLL) expect for the output location to be a directory. Documents are then written in the given directory using the document id as the filename and the format&rsquo;s extension, e.g. if the a document&rsquo;s id was 0001 and the format to write is Text, the file name would be 0001.txt. Note that if more than one document in the corpus has the same the id that only the last one processed will be written. </span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16"><span>When writing to an &ldquo;OPL&rdquo; (one per line) corpus format the provided resource should be the name of the file in which the documents will be written. However, if the corpus is being accessed in a distributed fashion the resource should be a directory. Note that distributed corpora can only be written in OPL formats.</span></p><h2 class="c9 c38 c16" id="h.jb6xb6g9fcsc"><span>Working with Corpora</span></h2><p class="c9 c16"><span>Hermes provides a number of methods </span><span>for working with and manipulating corpora. The Corpus object has a fluent interface. Corpora should be treated as immutable (not all implementations are). </span></p><h3 class="c9 c38" id="h.lg8fekg7n0iq"><span>Annotation</span></h3><p class="c9 c16"><span>The most common operation on corpora is to annotate its documents. Annotation of corpora is done using multiple threads for in memory and on disk corpora and as an Apache Spark job when distributed. </span></p><p class="c9 c8"><span></span></p><a id="t.93bc084aa51eddbeda1a0a0d62d536a848e8aac9"></a><a id="t.19"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c7"><span class="c21">Corpus</span><span class="c4">&nbsp;corpus </span><span class="c2">=</span><span class="c4">&nbsp;createCorpus</span><span class="c2">();</span></p><p class="c7"><span class="c18">try</span><span class="c13 c4">&nbsp;{</span></p><p class="c7"><span class="c4">&nbsp; &nbsp;corpus</span><span class="c2">.</span><span class="c4">annotate</span><span class="c2">(</span><span class="c21">Types</span><span class="c2">.</span><span class="c4">TOKEN</span><span class="c2">,</span><span class="c4">&nbsp;</span><span class="c21">Types</span><span class="c2">.</span><span class="c4">SENTENCE</span><span class="c2">,</span><span class="c4">&nbsp;</span><span class="c21">Types</span><span class="c2">.</span><span class="c13 c4">LEMMA)</span></p><p class="c7"><span class="c4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">.</span><span class="c4">write</span><span class="c2">(</span><span class="c21">Resources</span><span class="c2">.</span><span class="c18">from</span><span class="c2">(&quot;/</span><span class="c18">out</span><span class="c2">/</span><span class="c4">annotated</span><span class="c2">.</span><span class="c4">json_opl</span><span class="c2">&quot;));</span></p><p class="c7"><span class="c2">}</span><span class="c4">&nbsp;</span><span class="c18">catch</span><span class="c2">(</span><span class="c4">&nbsp;</span><span class="c21">IOException</span><span class="c4">&nbsp;e </span><span class="c2">)</span><span class="c13 c4">&nbsp;{</span></p><p class="c7"><span class="c4">&nbsp; &nbsp;e</span><span class="c2">.</span><span class="c4">printStackTrace</span><span class="c2">();</span></p><p class="c7"><span class="c4">}</span></p></td></tr></tbody></table><h3 class="c9 c38" id="h.e1398oqczo4"><span>Filtering and Querying</span></h3><p class="c9 c16"><span>Another common operation is to filter a corpus. One way in which this can be accomplished is by calling the </span><span class="c1">filter</span><span>&nbsp;method on a corpus with a supplied predicate.</span></p><p class="c9 c8"><span></span></p><a id="t.3590fecfb5c5ded3b4d46d16a574ba4423a162a6"></a><a id="t.20"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c7"><span class="c23 c54">//Filter the corpus to only have documents written in English</span></p><p class="c7"><span class="c21">Corpus</span><span class="c23">&nbsp;corpus </span><span class="c2">=</span><span class="c23">&nbsp;createCorpus</span><span class="c2">()</span></p><p class="c7"><span class="c23">Corpus </span><span class="c2">=</span><span class="c23">&nbsp;</span><span class="c23">corpus</span><span class="c2">.</span><span class="c23">filter</span><span class="c2">(</span><span class="c23">doc </span><span class="c13 c2">-&gt;</span></p><p class="c7"><span class="c23">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;doc</span><span class="c2">.</span><span class="c18">getLanguage()</span><span class="c2">&nbsp;== </span><span class="c21">Language</span><span class="c2">.</span><span class="c23">ENGLISH</span><span class="c13 c2">);</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>Another option is to query the corpus using a simple boolean query language via the query method.</span></p><p class="c9 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><a id="t.fdff2a0cdfdaa4b67f9d08f65936d00f4a6ad3e3"></a><a id="t.21"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c7"><span class="c13 c23 c54">//Query the corpus for documents containing &quot;silver&quot; and &quot;truck&quot; or &quot;silver&quot; //and &quot;car&quot; and are written in English</span></p><p class="c7"><span class="c21">Corpus</span><span class="c4">&nbsp;corpus </span><span class="c2">=</span><span class="c4">&nbsp;createCorpus</span><span class="c2">()</span></p><p class="c7"><span class="c4">corpus </span><span class="c2">=</span><span class="c4">&nbsp;corpus</span><span class="c2">.</span><span class="c4">query</span><span class="c2">(</span><span class="c23 c40">&quot;[LANGUAGE]:ENGLISH AND silver AND (truck OR car)&quot;</span><span class="c13 c2">);</span></p></td></tr></tbody></table><p class="c9 c16 c8"><span></span></p><p class="c9"><span>The query language supports the following operations:</span></p><p class="c9 c8"><span></span></p><a id="t.409381a0d1025d689798e341a04dbb0aa0322cc3"></a><a id="t.22"></a><table class="c31"><tbody><tr class="c14"><td class="c3 c58" colspan="1" rowspan="1"><p class="c36"><span class="c44 c41">Operator</span></p></td><td class="c45 c58" colspan="1" rowspan="1"><p class="c36"><span class="c44 c41">Description</span></p></td></tr><tr class="c33"><td class="c3" colspan="1" rowspan="1"><p class="c36"><span class="c13 c41">AND</span></p></td><td class="c45" colspan="1" rowspan="2"><p class="c5"><span class="c13 c41">Requires the queries, phrases, or words on the left and right of the operator to both be present in the document.</span></p></td></tr><tr class="c33"><td class="c3" colspan="1" rowspan="1"><p class="c36"><span class="c13 c41">&amp;</span></p></td></tr><tr class="c33"><td class="c3" colspan="1" rowspan="1"><p class="c36"><span class="c13 c41">OR</span></p></td><td class="c45" colspan="1" rowspan="2"><p class="c5"><span class="c13 c41">Requires for one of the queries, phrases, or words on the left and right of the operator to be present in the document.</span></p></td></tr><tr class="c33"><td class="c3" colspan="1" rowspan="1"><p class="c36"><span class="c13 c41">|</span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c36"><span class="c13 c41">-</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">Requires the query, phrase, or word on its right hand side to not be in the document.</span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c36"><span class="c13 c41">[ATTRIBUTE]:</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">Requires the value of the document attribute describe between the brackets [ ] &nbsp;to equal the value to the right of the colon.</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>Multiword phrases are expressed using quotes, e.g. &ldquo;United States&rdquo; would match the entire phrase whereas United AND States only requires the two words to present in the document in any order. The default operator when one is not specified is &ldquo;OR&rdquo;. </span></p><h3 class="c9 c38" id="h.mnmfrtv1j8ne"><span>Frequency Analysis</span></h3><p class="c9 c16"><span>A common step when analyzing a corpus is to calculate the term and document frequencies of the words in its documents. In Hermes, the frequency of any type of annotation can be calculated across a corpus using the </span><span class="c1">terms </span><span>method</span><span>. The analysis is defined using a </span><span class="c1">TermSpec</span><span>&nbsp;object, which provides a fluent interface for defining annotation type, conversion to string form, filters, and how to calculate the term values.</span><span>&nbsp;An example is as follows:</span></p><p class="c9 c16 c8"><span></span></p><a id="t.c23d53b355ae981b958d44180ab37050405bf172"></a><a id="t.23"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c7"><span class="c21">Corpus</span><span class="c4">&nbsp;corpus </span><span class="c2">=</span><span class="c4">&nbsp;createCorpus</span><span class="c2">();</span></p><p class="c7"><span class="c2">&#10112;</span><span class="c4">&nbsp;</span><span class="c21">TermSpec</span><span class="c4">&nbsp;spec </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c21">TermSpec</span><span class="c2">.</span><span class="c4">create</span><span class="c2">()</span></p><p class="c7"><span class="c4">&nbsp; </span><span class="c2">.</span><span class="c4">lemmatize</span><span class="c2">()</span></p><p class="c7"><span class="c4">&nbsp; </span><span class="c2">.</span><span class="c4">ignoreStopWords</span><span class="c2">()</span></p><p class="c7"><span class="c4">&nbsp; </span><span class="c2">.</span><span class="c4">valueCalculator</span><span class="c2">(</span><span class="c21">ValueCalculator</span><span class="c2">.</span><span class="c4">L1_NORM</span><span class="c2">);</span></p><p class="c7"><span class="c2">&#10113;</span><span class="c4">&nbsp;</span><span class="c21">Counter</span><span class="c2">&lt;</span><span class="c21">String</span><span class="c2">&gt;</span><span class="c4">&nbsp;tf </span><span class="c2">=</span><span class="c4">&nbsp;corpus</span><span class="c2">.</span><span class="c4">terms</span><span class="c2">(</span><span class="c4">spec</span><span class="c2">);</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>Line &#10112; shows creation of the term spec which defines the way we will extract terms. By default, the </span><span class="c1">TermSpec </span><span>will specify </span><span class="c1">TOKEN</span><span>&nbsp;annotations which will be converted to a string form using the </span><span class="c1">toString</span><span>&nbsp;method, all tokens will be kept, and the raw frequency will be calculated. In the specification shown in &#10112;, we specify that we want lemmas, will ignore stopwords, and want the returning counter to have its values L1</span><span class="c1">&nbsp;</span><span>normalized.</span></p><h3 class="c9 c38" id="h.x0uljfvxdfon"><span>Extracting </span><span>N-Grams</span></h3><p class="c9 c16"><span>Hermes provides a methodology for extracting n-grams which is similar to extract terms. A </span><span class="c1">NGramSpec</span><span>&nbsp;is used to specify the extraction criteria. An </span><span class="c1">NGramSpec</span><span>&nbsp;is created by specifying the minimum and maximum n-gram size.</span></p><p class="c9 c8"><span></span></p><a id="t.a0d881bc74c6e2e84d88ae5f6c726c212c790bf6"></a><a id="t.24"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c7"><span class="c21">Corpus</span><span class="c23">&nbsp;corpus </span><span class="c2">=</span><span class="c23">&nbsp;createCorpus</span><span class="c2">();</span></p><p class="c7"><span class="c2">&#10112;</span><span class="c23">&nbsp;</span><span class="c21">NGramSpec</span><span class="c23">&nbsp;spec </span><span class="c2">=</span><span class="c23">&nbsp;</span><span class="c21">NGramSpec</span><span class="c2">.</span><span class="c23">order</span><span class="c2">(1,3)</span></p><p class="c7"><span class="c23">&nbsp; </span><span class="c2">.</span><span class="c23">lemmatize</span><span class="c2">()</span></p><p class="c7"><span class="c23">&nbsp; </span><span class="c2">.</span><span class="c23">ignoreStopWords</span><span class="c2">()</span></p><p class="c7"><span class="c23">&nbsp; </span><span class="c2">.</span><span class="c23">valueCalculator</span><span class="c2">(</span><span class="c21">ValueCalculator</span><span class="c2">.</span><span class="c23">L1_NORM</span><span class="c2">);</span></p><p class="c7"><span class="c2">&#10113;</span><span class="c23">&nbsp;</span><span class="c21">Counter</span><span class="c2">&lt;</span><span class="c21">Tuple</span><span class="c2">&gt;</span><span class="c23">&nbsp;tf </span><span class="c2">=</span><span class="c23">&nbsp;corpus</span><span class="c2">.</span><span class="c23">ngrams</span><span class="c2">(</span><span class="c23">spec</span><span class="c2">);</span></p></td></tr></tbody></table><p class="c9 c8"><span class="c23"></span></p><p class="c9"><span>Line &#10112; shows creation of the n-gram spec. All </span><span class="c1">NGramSpec</span><span>&nbsp;must have their order specified at creation, this can be done by specifying a min and max as in &#10112; (which will result in unigrams, bigrams, and trigrams being extracted), an order method which takes a single int argument (will extract only n-grams of that order), or one the convenience methods common n-gram sizes. </span><span>By default, the </span><span class="c1">NGramSpec </span><span>will specify </span><span class="c1">TOKEN</span><span>&nbsp;annotations which will be converted to a string form using the </span><span class="c1">toString</span><span>&nbsp;method, all tokens will be kept, and the raw frequency will be calculated. In the specification shown in &#10112;, we specify that we want lemmas, will ignore stopwords (n-grams containing a stopword will be ignored), and want the returning counter to have its values L1</span><span class="c1">&nbsp;</span><span>normalized. The method</span><span>&nbsp;returns a </span><span class="c1">Counter&lt;Tuple&gt; </span><span>where each element of the </span><span class="c1">Tuple </span><span>is the string form of the corresponding tokens. </span></p><h3 class="c9 c38" id="h.fpsg8ck0p5ix"><span>Sampling</span></h3><p class="c9"><span>The </span><span class="c1">Corpus</span><span>&nbsp;class provides a method for sampling documents. Two methods exist on the </span><span class="c1">Corpus </span><span>object:</span></p><p class="c9 c8"><span></span></p><ol class="c61 lst-kix_pieid35nlkcr-0 start" start="1"><li class="c42 c9"><span class="c4">sample</span><span class="c2">(</span><span class="c18">int</span><span class="c4">&nbsp;</span><span class="c23">size</span><span class="c4">)</span></li><li class="c42 c9"><span class="c4">sample</span><span class="c2">(</span><span class="c18">int</span><span class="c4">&nbsp;</span><span class="c23">size</span><span class="c2">,</span><span class="c4">&nbsp;</span><span class="c21">Random</span><span class="c4">&nbsp;random)</span></li></ol><p class="c9 c8"><span></span></p><p class="c9"><span>Both return a new corpus and take the sample size as the first parameter. The second method takes an additional parameter of type </span><span class="c1">Random</span><span>&nbsp;which is used to determine inclusion of a document in the sample. </span><span>The sampling algorithm is dependent on the type of corpus with reservoir sampling being the default algorithm. Note that for non-distributed corpora the sample size must be able to fit into memory. </span></p><h3 class="c9 c38" id="h.o28ivlpf4w25"><span>Grouping</span></h3><p class="c9"><span>The </span><span class="c1">Corpora </span><span>class provides a </span><span class="c1">groupBy</span><span>&nbsp;method for grouping documents by an arbitrary key. The method returns a </span><span class="c1">Multimap&lt;K, Document&gt;</span><span>&nbsp;where </span><span class="c1">K</span><span>&nbsp;is the key type and takes a function that maps a </span><span class="c1">Document</span><span>&nbsp;to </span><span class="c1">K</span><span>. The following code example shows where this may of help.</span></p><p class="c9 c8"><span></span></p><a id="t.49e024e6311c8cb17d666aa0d2a753518f9850e1"></a><a id="t.25"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c7"><span class="c21">Corpus</span><span class="c4">&nbsp;corpus </span><span class="c2">=</span><span class="c4">&nbsp;createCorpus</span><span class="c2">();</span></p><p class="c7"><span class="c23 c54">//Group the documents by their category label (String)</span></p><p class="c7"><span class="c4">corpus</span><span class="c2">.</span><span class="c4">groupBy</span><span class="c2">(</span><span class="c4">doc </span><span class="c2">-&gt;</span><span class="c4">&nbsp;doc</span><span class="c2">.</span><span class="c4">getAttributeAsString</span><span class="c2">(</span><span class="c21">Attrs</span><span class="c2">.</span><span class="c4">CATEGORY</span><span class="c2">));</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>Note that because this method returns a </span><span class="c1">Multimap</span><span>, the entire corpus must be able to fit in memory.</span></p><h3 class="c9 c38" id="h.fznfvc8wld62"><span>Machine Learning</span></h3><p class="c9"><span>Machine learning is commonly used for providing annotations and relations, determining the value of an attribute for a document or annotation, or determining the topics discussed in a corpus. Training of these types of machine learning models is done from a corpus. In the case of supervised learning the corpus contains the gold standard, or correct, annotations, relations, or attributes. Herme&rsquo;s </span><span class="c1">Corpus</span><span>&nbsp;class makes it easy to construct (see </span><span class="c1">asLabeledStream</span><span>, </span><span class="c1">asClassificationDataSet</span><span>, </span><span class="c1">asRegressionDataSet</span><span>, and </span><span class="c1">asSequenceDataSet</span><span>&nbsp;in the Javadoc) an Apollo dataset which various machine learning algorithms can be trained or applied. </span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><p class="c9 c16 c8"><span></span></p><a id="t.f729b9daded90d15fca33d6f477109940d13bc6a"></a><a id="t.26"></a><table class="c17"><tbody><tr class="c14"><td class="c37" colspan="1" rowspan="1"><p class="c36"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 27.77px; height: 28.50px;"><img alt="bullseye.gif" src="images/image00.gif" style="width: 27.77px; height: 28.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c28" colspan="1" rowspan="1"><p class="c15 c9"><span>Take a look at </span><span class="c47">GettingStarted.java</span><span>, </span><span class="c47">CorpusExample.java</span><span>, </span><span class="c47">MLExample.java</span><span>, and </span><span class="c47">SparkExample.java </span><span class="c13 c41">in the Hermes examples project to see a complete example.</span></p></td></tr></tbody></table><h1 class="c9 c38 c16" id="h.kwb30bl9y5fh"><span>Annotations</span></h1><p class="c9 c16"><span>An annotation associates a type, e.g. token, sentence, named entity, to a specific span of characters in a document, which may include the entire document. Annotations typically have attributes, e.g. part-of-speech, entity type, etc, and relations, e.g. dependency and co-reference, associated with them. All annotations are instantiated through the </span><span class="c1">Annotation</span><span>&nbsp;class which is a descendent of </span><span class="c1">HString</span><span>. The annotation is defined by its type, which is retrieved using the </span><span class="c1">getType()</span><span>&nbsp;method.</span><span>&nbsp; </span></p><h2 class="c9 c16" id="h.kcckxcil65m2"><span>Annotation Types</span></h2><p class="c9 c16"><span>Annotation types represent the formal definition of an annotation. </span><span>In particular, it defines the type name, parent type, annotator providing annotations of the type, and optionally a set of expected attributes on the provided annotations. Annotation type information is instantiated via the </span><span class="c1">AnnotationType</span><span>&nbsp;class, which defines the type name. The rest of the type&rsquo;s definition is defined via configuration using the pattern Annotation.TYPE_NAME.property. &nbsp;An excerpt of such a configuration is shown below:</span></p><p class="c9 c8"><span></span></p><a id="t.229b5e56034fcec7d76f72962e0c242b1b48eaf3"></a><a id="t.27"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c10 c9"><span class="c13 c4">Annotation {<br> &nbsp; ENTITY {<br> &nbsp; &nbsp; &nbsp;attributes = ENTITY_TYPE, CONFIDENCE<br> &nbsp; }<br> &nbsp; REGEX_ENTITY {<br> &nbsp; &nbsp; parent = ENTITY<br> &nbsp; &nbsp; annotator {<br> &nbsp; &nbsp; &nbsp; ENGLISH = @{ENGLISH_ENTITY_REGEX}<br> &nbsp; &nbsp; &nbsp; JAPANESE = @{JAPANESE_ENTITY_REGEX}<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; attributes = PATTERN<br> &nbsp; }<br>}</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>Annotation types are hierarchical. Each type can specify a parent type by setting the </span><span class="c1">parent</span><span>&nbsp;configuration property to the parent&rsquo;s type name. </span><span>When a type does not define its parent the ROOT annotation type is assumed. The hierarchy is used for retrieving annotations and for inheriting attributes. &nbsp;For example, retrieving ENTITY types from a document will include all children types, e.g. REGEX_ENTITY in the configuration shown above. </span></p><p class="c9 c8"><span></span></p><p class="c9"><span>An annotation type can, optionally, define the set of expected attributes for annotations of this type. Currently, this attribute information only serves as documentation. Attribute information is defines as a comma separated value list of attribute names.</span></p><p class="c9 c8"><span></span></p><p class="c9 c16"><span>Finally, annotation types define the annotator used to provide annotations of their type. Default and language specific annotators can be specified. </span><span>The default annotator is assigned using the </span><span class="c1">Annotation.TYPE_NAME.annotator</span><span>&nbsp;property. Language specific annotators are defined by appending the language name to the property name. The value of the annotator is either the fully qualified class name of the annotator implementation or a bean reference (e.g. @{ENGLISH_ENTITY_REGEX}; see Appendix B or Mango for information on bean definition). </span></p><h2 class="c9 c38" id="h.ufc86mn708m9"><span>Core Annotation Types</span></h2><p class="c9"><span>Hermes provides a number of annotation types out-of-the-box and the ability to create custom annotation types easily from lexicons and existing training data. Here, we discuss the core set of annotation types that Hermes provides.</span></p><h3 class="c9 c38" id="h.m20hmpx2jr34"><span>Token</span></h3><p class="c9"><span>Tokens represent, typically, the lowest level of annotation on a document. Hermes equates a token to mean a word (this is not always the case in other libraries depending on the language). A majority of the attribute and relation annotators are designed to enhance (i.e. add attributes and relations) to tokens. For example, the part-of-speech annotator adds part-of-speech information to tokens and the MaltParser annotator provides dependency relations between tokens. The default annotator for tokens works at various level of correctness for western languages that use white space between words (e.g. English, French, and Spanish). </span></p><h3 class="c9 c38" id="h.1wom5lbmm526"><span>Sentence</span></h3><p class="c9"><span>Hermes provides a default sentence annotator that uses Java&rsquo;s bulit-in </span><span class="c1">BreakIterator</span><span>&nbsp;coupled with heuristics to fix a number of common errors. Additionally, the OpenNLP module provides a wrapper around OpenNLP&rsquo;s machine learning based sentence splitter. </span></p><h3 class="c9 c38" id="h.x7xyxi7u4imd"><span>Phrase Chunk</span></h3><p class="c9"><span>Phrase chunks represent the output of a shallow parse (sometimes also referred to as a light parse). A chunk is associated with a part-of-speech, e.g noun, verb, adjective, or preposition. Hermes provides two machine learning based annotators for phrase chunks. The first is part of the main Hermes package (the default) which uses the Apollo machine learning framework is trained off the CoNLL shared task dataset. The second one is a part of the OpenNLP module and wraps OpenNLP&rsquo;s </span><span class="c1">ChunkerME</span><span>.</span></p><h3 class="c9 c38" id="h.w2icg9bg40rk"><span>Entity</span></h3><p class="c9"><span>The entity annotation type serves as a parent for various named entity recognizers. Entities are associated with an </span><span class="c1">EntityType</span><span>, which is a hierarchy defining the types of entities (e.g. a entity type of </span><span class="c1">MONEY</span><span>&nbsp;has the parent </span><span class="c1">NUMBER</span><span>). The default entity annotator is a </span><span class="c1">SubTypeAnnotator</span><span>, which combines the output of multiple other annotators each of which supplies an child &nbsp;annotation type of </span><span class="c1">ENTITY</span><span>. &nbsp;Currently, one sub annotator is assigned which supplies </span><span class="c1">TOKEN_TYPE_ENTITY</span><span>. This annotator uses output from the default tokenizer to create entities for types like </span><span class="c1">EMAIL, URL, MONEY, NUMBER, </span><span>and </span><span class="c1">EMOTICON</span><span>. </span></p><p class="c9 c8"><span></span></p><p class="c9"><span>The OpenNLP modules provides a wrapper around OpenNLP&rsquo;s entity extractor, which provides </span><span class="c1">OPENNLP_ENTITY</span><span>&nbsp;annotations. This type is automatically added when the opennlp-english configuration is loaded. </span></p><h3 class="c9 c38" id="h.7n20nzzhmfpe"><span>Word Sense</span></h3><p class="c9"><span>The WordNet module provides an interface to working with Wordnets. A wordnet is a lexical database which groups words into synonyms, called synsets, and provides relations between synsets and forms of individual words. The hermes WordNet module has been tested with the English WordNet. </span></p><p class="c9 c8"><span></span></p><p class="c9"><span>The </span><span class="c1">WORD_SENSE</span><span>&nbsp;annotation maps words and phrases in a document to their corresponding entries in WordNet. The annotation provides all possible mappings, i.e. it does not attempt to disambiguate the sense. </span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><a id="t.ed265affa47f5e1a617359d24ad6f32037cfea3b"></a><a id="t.28"></a><table class="c17"><tbody><tr class="c14"><td class="c37" colspan="1" rowspan="1"><p class="c36"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 27.77px; height: 28.50px;"><img alt="bullseye.gif" src="images/image00.gif" style="width: 27.77px; height: 28.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c28" colspan="1" rowspan="1"><p class="c15 c9"><span>Take a look at </span><span class="c47">CustomAnnotator.java, LexiconExample.java, </span><span>and </span><span class="c47">GettingStarted.java </span><span class="c13 c41">in the Hermes examples project to see examples of using annotations and creating custom annotation types.</span></p></td></tr></tbody></table><h1 class="c9 c38 c16" id="h.l6deiq7s7q00"><span>Attributes</span></h1><p class="c9 c16"><span>Attributes define the properties and/or metadata associated with a </span><span class="c1">HString</span><span>. Examples include, part-of-speech, author, document source, lemma, publication data, and entity type. Attributes are represented using a type and a value, i.e. a key value pair. </span></p><h2 class="c9 c38" id="h.in9w9kvxct1h"><span>Attribute Types</span></h2><p class="c9"><span>Attribute types define a name, value type, and optionally an annotator that can produce the given attribute type and codec for reading and writing the attribute type. Attribute types are represented using the </span><span class="c1">AttributeType </span><span>class which inherits from </span><span class="c1">AnnotatableType</span><span>. &nbsp;The rest of the type&rsquo;s definition is defined via configuration using the pattern Attribute.TYPE_NAME.property.. &nbsp;An excerpt of such a configuration is shown below:</span></p><p class="c9 c8"><span class="c1"></span></p><a id="t.f94b61697ef706de00c4329cb0d0731b7d08bdab"></a><a id="t.29"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c10 c9"><span class="c13 c4">Attribute {</span></p><p class="c10 c9"><span class="c13 c4">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PART_OF_SPEECH {</span></p><p class="c10 c9"><span class="c13 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; type = hermes.attribute.POS</span></p><p class="c10 c9"><span class="c13 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;annotator = hermes.annotator.DefaultPOSAnnotator</span></p><p class="c10 c9"><span class="c13 c4">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model {</span></p><p class="c10 c9"><span class="c13 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ENGLISH = ${models.dir}/en/en-pos.model.gz</span></p><p class="c10 c9"><span class="c13 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c10 c9"><span class="c13 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c10 c9"><span class="c13 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SENSE {</span></p><p class="c9 c10"><span class="c13 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type = List</span></p><p class="c10 c9"><span class="c13 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elementType = hermes.wordnet.Sense</span></p><p class="c10 c9"><span class="c13 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;codec = hermes.annotator.SenseCodec</span></p><p class="c10 c9"><span class="c13 c4">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c10 c9"><span class="c23">}</span></p></td></tr></tbody></table><p class="c9 c16 c8"><span class="c1"></span></p><p class="c9"><span>Minimally, an attribute type should define its value type, i.e. the Java class representing values of this attribute. This is defined via configuration using Mango&rsquo;s </span><span class="c1">ValueType</span><span>&nbsp;specification. In this specification the </span><span class="c1">type</span><span>&nbsp;property is used to define the type. Collection types can specify an </span><span class="c1">elementType</span><span>&nbsp;relating to type of the elements in the collection and Map types can specify a </span><span class="c1">keyType</span><span>&nbsp;and </span><span class="c1">valueType</span><span>&nbsp;relating to the type of the keys and values respectively. By default all attribute values are defined as type </span><span class="c1">String</span><span>. Correct type information is critical for reading in saved documents. </span></p><p class="c9 c8"><span></span></p><p class="c9"><span>As with other </span><span class="c1">AnnotatbleType</span><span>, an annotator can be specified using the </span><span class="c1">annotator</span><span>&nbsp;property. This specification can be language specific by appending or prepending the language name, e.g. JAPANESE, to the </span><span class="c1">annotator</span><span>&nbsp;property. Additional information for the annotator may also be stored, e.g. </span><span class="c1">model</span><span>&nbsp;for the </span><span class="c1">PART_OF_SPEECH</span><span>&nbsp;attribute type in the example given above. </span></p><h2 class="c9 c38" id="h.7181v2o14wjz"><span>Attribute Value Codecs</span></h2><p class="c9"><span>Attribute values are written to and read from documents using an </span><span class="c1">AttributeValueCodec</span><span>. A number of codecs are predefined for the common value types and are listed below. </span></p><p class="c9 c8"><span></span></p><a id="t.54dafa7504654b11c401802edce575c1ece76fe8"></a><a id="t.30"></a><table class="c31"><tbody><tr class="c14"><td class="c70" colspan="1" rowspan="1"><ul class="c61 lst-kix_w4y7hkbtg4ow-0 start"><li class="c5 c42"><span class="c13 c41">Double</span></li></ul></td><td class="c70" colspan="1" rowspan="1"><ul class="c61 lst-kix_w4y7hkbtg4ow-0"><li class="c5 c42"><span class="c13 c41">Integer</span></li></ul></td></tr><tr class="c14"><td class="c70" colspan="1" rowspan="1"><ul class="c61 lst-kix_w4y7hkbtg4ow-0"><li class="c5 c42"><span class="c13 c41">String</span></li></ul></td><td class="c70" colspan="1" rowspan="1"><ul class="c61 lst-kix_w4y7hkbtg4ow-0"><li class="c5 c42"><span class="c13 c41">Long</span></li></ul></td></tr><tr class="c14"><td class="c70" colspan="1" rowspan="1"><ul class="c61 lst-kix_w4y7hkbtg4ow-0"><li class="c5 c42"><span class="c13 c41">Boolean</span></li></ul></td><td class="c70" colspan="1" rowspan="1"><ul class="c61 lst-kix_w4y7hkbtg4ow-0"><li class="c5 c42"><span class="c13 c41">Part-of-Speech</span></li></ul></td></tr><tr class="c14"><td class="c70" colspan="1" rowspan="1"><ul class="c61 lst-kix_w4y7hkbtg4ow-0"><li class="c5 c42"><span class="c13 c41">EntityType</span></li></ul></td><td class="c70" colspan="1" rowspan="1"><ul class="c61 lst-kix_w4y7hkbtg4ow-0"><li class="c5 c42"><span class="c13 c41">Tag</span></li></ul></td></tr><tr class="c14"><td class="c70" colspan="1" rowspan="1"><ul class="c61 lst-kix_w4y7hkbtg4ow-0"><li class="c5 c42"><span class="c13 c41">Date</span></li></ul></td><td class="c70" colspan="1" rowspan="1"><ul class="c61 lst-kix_w4y7hkbtg4ow-0"><li class="c5 c42"><span class="c13 c41">Language</span></li></ul></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9 c16"><span>Custom codecs can be defined using the </span><span class="c1">codec</span><span>&nbsp;property which is the fully qualified name of the codec class. Custom codecs should inherit from the </span><span class="c1">AttributeValueCodec</span><span>. The </span><span class="c1">CommonCodecs</span><span>&nbsp;class can be examined to determine how to implement a custom codec.</span></p><h2 class="c9 c38" id="h.335imo78aqzi"><span>Tag Attributes</span></h2><p class="c9"><span>Commonly, annotations have an associated tag which acts as label. Examples of tags include part-of-speech and entity type. Hermes represents these tags using the interface </span><span class="c1">Tag</span><span>, which defines methods for retrieving the tag&rsquo;s name and determining if one tag is an instance of another. Because of their ubiquitousness, Hermes provides a convenience method for accessing the tag of an annotation named </span><span class="c1">getTag</span><span>. &nbsp;Each annotation type defines the attribute type that represents its tag using the </span><span class="c1">tag</span><span>&nbsp;property. &nbsp;An example using the </span><span class="c1">TOKEN</span><span>&nbsp;annotation type is listed below. If no tag is specified, a default attribute of TAG is used. &nbsp;</span></p><p class="c9 c8"><span class="c1"></span></p><a id="t.77140456bd574ebc26bd8c229f0e4b66051af962"></a><a id="t.31"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c10 c9"><span class="c13 c4">TOKEN {</span></p><p class="c10 c9"><span class="c13 c4">&nbsp; &nbsp; annotator = hermes.annotator.DefaultTokenAnnotator</span></p><p class="c10 c9"><span class="c13 c4">&nbsp; &nbsp; tag = PART_OF_SPEECH</span></p><p class="c10 c9"><span class="c13 c4">}</span></p></td></tr></tbody></table><p class="c9 c8"><span class="c1"></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><a id="t.ed265affa47f5e1a617359d24ad6f32037cfea3b"></a><a id="t.32"></a><table class="c17"><tbody><tr class="c14"><td class="c37" colspan="1" rowspan="1"><p class="c36"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 27.77px; height: 28.50px;"><img alt="bullseye.gif" src="images/image00.gif" style="width: 27.77px; height: 28.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c28" colspan="1" rowspan="1"><p class="c15 c9"><span>Take a look at </span><span class="c47">CustomAnnotator.java, LexiconExample.java, </span><span>and </span><span class="c47">GettingStarted.java </span><span class="c13 c41">in the Hermes examples project to see examples of using annotations and creating custom annotation types.</span></p></td></tr></tbody></table><h1 class="c9 c38 c16" id="h.hywdg1ocij94"><span>Relations</span></h1><p class="c9"><span>Relations provide a mechanism to link two </span><span class="c1">RelationObject</span><span>s</span><span>. Relations are directional, i.e. they have a source and a target, and form a directed graph between annotations on the document. &nbsp;Relations may represent any type of link, but often represent syntactic (e.g. dependency relations), semantic (e.g. semantic roles), or pragmatic (e.g. dialog acts) information. &nbsp;Relations are accessed using the </span><span class="c1">get</span><span>&nbsp;method taking a </span><span class="c1">RelationType</span><span>&nbsp;which represents the type of relation desired. Additionally, relations of sub-annotations, i.e. annotations whose span is enclosed by the annotation from which </span><span class="c1">get</span><span>&nbsp;is being called. Other methods allow for the retrieval of connected annotations, </span><span class="c1">sources</span><span>&nbsp;and </span><span class="c1">targets</span><span>, representing the incoming and outgoing neighbors respectively. </span></p><h2 class="c9 c38" id="h.fozs7588yg96"><span>Relation Types</span></h2><p class="c9"><span>Relations, like attributes, are stored as key value pairs with the key being the </span><span class="c1">RelationType</span><span>&nbsp;and the value being a </span><span class="c1">String</span><span>&nbsp;representing the label. </span><span class="c1">RelationType</span><span>&nbsp;implements </span><span class="c1">AnnotatableType</span><span>&nbsp;allowing relations to be added to documents and annotations through annotation. As with attributes and annotations, relation type information is specified through configuration. Configuration of relation types only defines the annotator, and optionally model parameters, &nbsp;using the Relation.TYPE_NAME.annotator property. &nbsp;</span></p><h2 class="c9 c38" id="h.m2gyum6xzqq6"><span>Dependency Relations</span></h2><p class="c9"><span>Dependency relations connect and label pairs of words where one word represents the head and the other the dependent. The assigned relations are syntactic, e.g. nn for noun-noun, nsubj for noun subject of a predicate, and advmod for adverbial modifier, and the relation points from the dependent (source) to the head (target). &nbsp;Because of their wide use, Hermes provides convenience methods for working dependency relations. Namely, the </span><span class="c1">parent</span><span>&nbsp;and </span><span class="c1">children</span><span>&nbsp;methods provide access to the dependents and heads of a specific token and the </span><span class="c1">dependencyRelation</span><span>&nbsp;method provides access to the head (parent) of the token and the relation between it and its head. </span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><a id="t.a5997672340fdc42953d5f388acffb6f435534e8"></a><a id="t.33"></a><table class="c17"><tbody><tr class="c14"><td class="c37" colspan="1" rowspan="1"><p class="c36"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 27.77px; height: 28.50px;"><img alt="bullseye.gif" src="images/image00.gif" style="width: 27.77px; height: 28.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c28" colspan="1" rowspan="1"><p class="c15 c9"><span>Take a look at </span><span class="c47">DependencyParseExample.java </span><span>and </span><span class="c47">SparkSVOExample.java </span><span class="c13 c41">in the Hermes examples project to see examples of using relations.</span></p></td></tr></tbody></table><h1 class="c9 c38" id="h.ygs42yp7c45a"><span>Annotators</span></h1><p class="c9"><span>Annotators provide the means for creating and adding annotations, attributes, and relations on documents. An annotator satisfies, i.e. provides, one or more </span><span class="c1">AnnotatableType </span><span>(</span><span class="c1">AnnotationType</span><span>, </span><span class="c1">AttributeType</span><span>, or </span><span class="c1">RelationType</span><span>). &nbsp;In order to produce its annotations an annotator may require one or more </span><span class="c1">AnnotableType</span><span>&nbsp;to be present. For example, The phrase chunk annotator provides the </span><span class="c1">PHRASE_CHUNK</span><span>&nbsp;annotation type while requiring the presence of the </span><span class="c1">TOKEN</span><span>&nbsp;annotation type and </span><span class="c1">PART_OF_SPEECH</span><span>&nbsp;attribute type. Annotator implementations define the methodology for creating the annotation via the </span><span class="c1">annotate</span><span>&nbsp;method which takes a </span><span class="c1">Document </span><span>object. Additionally, each annotator provides a version number for the </span><span class="c1">AnnotatableType</span><span>s it produces.</span></p><p class="c9 c8"><span></span></p><p class="c9"><span>Annotators are not typically used directly, but instead are used as part of a </span><span class="c1">Pipeline</span><span>. Pipelines take care of ordering the execution of the annotators so that all required </span><span class="c1">AnnotatableType</span><span>&nbsp;are satisfied before the annotator is called. </span></p><h2 class="c9 c38" id="h.x83i9ie16mf3"><span>Sentence Level Annotators</span></h2><p class="c9"><span>Sentence level annotators work on individual sentences. They have a minimum requirement of </span><span class="c1">SENTENCE</span><span>&nbsp;and </span><span class="c1">TOKEN </span><span>annotation types. Additional types can be specified by overriding the </span><span class="c1">furtherRequires</span><span>&nbsp;method. </span></p><h2 class="c9 c38" id="h.9c0rsqit60of"><span>Sub Type Annotators</span></h2><p class="c9"><span>In certain cases, such as Named Entity Recognition, there may exist a number of different methodologies which we would want to combine to satisfy a parent annotation type. In these situations a </span><span class="c1">SubTypeAnnotator </span><span>can be used. A </span><span class="c1">SubTypeAnnotator</span><span>&nbsp;satisfies an </span><span class="c1">AnnotationType</span><span>&nbsp;by calling multiple other annotators that satisfy one or more of its sub types. For example, the </span><span class="c1">EntityAnnotator</span><span>&nbsp;provides the </span><span class="c1">ENTITY</span><span>&nbsp;annotation type, by using sub annotators. By default the only sub annotator is the </span><span class="c1">TOKEN_ENTITY_TYPE</span><span>&nbsp;annotator, but this can be extended to use lexicons, and the OpenNLP entity annotator.</span></p><h1 class="c9 c38 c74" id="h.bx1ncgdfog91"><span></span></h1><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><a id="t.525f02107f5347cbb348216ecfb64fdc94533e5e"></a><a id="t.34"></a><table class="c17"><tbody><tr class="c14"><td class="c37" colspan="1" rowspan="1"><p class="c36"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 27.77px; height: 28.50px;"><img alt="bullseye.gif" src="images/image00.gif" style="width: 27.77px; height: 28.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c28" colspan="1" rowspan="1"><p class="c15 c9"><span>Take a look at </span><span class="c47">CustomAnnotator.java </span><span class="c13 c41">in the Hermes examples project to see examples of creating and using a custom annotator.</span></p></td></tr></tbody></table><h1 class="c9 c38" id="h.yrbtudkfm0bb"><span>Information Extraction</span></h1><p class="c9"><span>The goal of Information Extraction is to turn unstructured data in structured information. Hermes provides </span><span>a variety of tools from which custom extractors can be built. In particular, Hermes has extensive support lexicon-based matching, Token based regular expressions, A system named Caduceus for rule-based extraction, and simplified interfaces for BIO style sequence labelers.</span></p><h2 class="c9 c38" id="h.v7uzt4um6la7"><span>Lexicon Matching</span></h2><p class="c9"><span>A traditional approach to information extraction incorporates the use of lexicons, also called gazetteers, for finding specific lexical items in text. Hermes provides methods for matching lexical items using simple lookup, probabilistically, treating the items as case-sensitive or case-insensitive, and through the use of constraints, such as part-of-speech. All lexicons must implement the </span><span class="c1">Lexicon</span><span>&nbsp;interface, which defines methods for adding lexicon entries (</span><span class="c1">LexionEntry</span><span>), testing the existence of lexical items in a </span><span class="c1">HString</span><span>, getting the associated parameters of the lexicon, and constructing matches for a given </span><span class="c1">HString</span><span>. &nbsp;</span></p><p class="c8 c9"><span></span></p><p class="c9"><span>Lexicons can be probabilistic (i.e. each lexical item - tag pair is associated with a probability), case sensitive or insensitive, and constrained (e.g. part-of-speech must be a noun). &nbsp;Matching of probabilistic lexicons is done using the Viterbi algorithm, which maximizes the global probability of the assigned tags over the given </span><span class="c1">HString</span><span>&nbsp;(typically this should be at the sentence level.) Constraints can also be added to lexicon matches. Constraint syntax is the same as is used for token-based regular expressions (described in the next section), but is limited to matching a single token (however lookahead and parent operators can be used.)</span></p><p class="c9 c8"><span></span></p><p class="c9"><span>In addition to the </span><span class="c1">Lexicon</span><span>&nbsp;interface, a lexicon may also implement the </span><span class="c1">PrefixSearchable</span><span>&nbsp;interface. Lexicon implementations that are </span><span class="c1">PrefixSearchable</span><span>&nbsp;have an extra method that determines if a given </span><span class="c1">HString</span><span>&nbsp;is a prefix match for a lexicon entry. This can result in faster matching as spans of text can be skipped in the search process when there is no prefix match. </span></p><p class="c9 c8"><span></span></p><p class="c9"><span>Lexicons are constructed using the </span><span class="c1">LexiconSpec</span><span>&nbsp;class, which includes a builder class. An example is as follows:</span></p><p class="c9 c8"><span></span></p><a id="t.8543db855f94aa29e1171d297556103b42cdaaf2"></a><a id="t.35"></a><table class="c17"><tbody><tr class="c14"><td class="c57" colspan="1" rowspan="1"><p class="c5"><span class="c21">Lexicon</span><span class="c4">&nbsp;lexicon </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c21">LexiconSpec</span><span class="c2">.</span><span class="c4">builder</span><span class="c2">()</span><span class="c4"><br> &nbsp; </span><span class="c2">.</span><span class="c4">caseSensitive</span><span class="c2">(</span><span class="c18">false</span><span class="c2">)</span><span class="c4"><br> &nbsp; </span><span class="c2">.</span><span class="c4">hasConstraints</span><span class="c2">(</span><span class="c18">false</span><span class="c2">)</span><span class="c4"><br> &nbsp; </span><span class="c2">.</span><span class="c4">probabilistic</span><span class="c2">(</span><span class="c18">false</span><span class="c2">)</span><span class="c4"><br> &nbsp; </span><span class="c2">.</span><span class="c4">tagAttribute</span><span class="c2">(</span><span class="c21">Types</span><span class="c2">.</span><span class="c4">ENTITY_TYPE</span><span class="c2">)</span><span class="c4"><br> &nbsp; </span><span class="c2">.</span><span class="c4">resource</span><span class="c2">(</span><span class="c21">Resources</span><span class="c2">.</span><span class="c4">fromClasspath</span><span class="c2">(</span><span class="c23 c40">&quot;people.dict&quot;</span><span class="c2">))</span><span class="c4"><br> &nbsp; </span><span class="c2">.</span><span class="c4">build</span><span class="c2">().</span><span class="c4">create</span><span class="c2">();</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>The resulting lexicon will match case-insensitively, each match will be associated with a </span><span class="c1">ENTITY_TYPE</span><span>&nbsp;tag, and lexicon entries will be loaded from the </span><span class="c1">people.dict</span><span>&nbsp;file which is csv formatted with the first column the lexical item and the second column the tag. &nbsp;</span></p><p class="c9 c8"><span></span></p><p class="c9"><span>The csv format for lexicons specifies two to four columns, with the first two columns being the lexeme (lexical item) and tag respectively. The next two columns are optional and are the lexeme&rsquo;s associated probability and constraint. Both columns may be omitted. An example of the format is as follows:</span></p><p class="c9 c8"><span></span></p><a id="t.6b706a5a974cbb4365f69d48a32f3414ae66b052"></a><a id="t.36"></a><table class="c17"><tbody><tr class="c14"><td class="c3 c58" colspan="1" rowspan="1"><p class="c36"><span class="c44 c41">Lexeme</span></p></td><td class="c3 c58" colspan="1" rowspan="1"><p class="c36"><span class="c44 c41">Tag</span></p></td><td class="c3 c58" colspan="1" rowspan="1"><p class="c36"><span class="c44 c41">Probability</span></p></td><td class="c3 c58" colspan="1" rowspan="1"><p class="c36"><span class="c44 c41">Constraint</span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">rabbit</span></p></td><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">ANIMAL</span></p></td><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">0.8</span></p></td><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">($NOUN)</span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">rabbit</span></p></td><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">ACTION</span></p></td><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">0.8</span></p></td><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">($VERB)</span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">think</span></p></td><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">COGNITION</span></p></td><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">0.6</span></p></td><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">(/&gt; I)</span></p></td></tr><tr class="c14"><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">think tank</span></p></td><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">GROUP</span></p></td><td class="c3" colspan="1" rowspan="1"><p class="c5"><span class="c13 c41">0.6</span></p></td><td class="c3" colspan="1" rowspan="1"><p class="c5 c8"><span class="c13 c41"></span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>Lexicons can be managed using the </span><span class="c1">LexiconManager</span><span>, which associates lexicons with a name. This allows for lexicons to be defined via configuration and then to be loaded and retrieved by their name (this is particularly useful for annotators that use lexicons). &nbsp;Lexicons defined via configuration files follow the </span><span class="c1">LexiconSpec</span><span>&nbsp;builder naming convention. &nbsp;An example is as follows:</span></p><p class="c9 c8"><span></span></p><a id="t.f80a2a96008ebb3901d3b9b19e1a81202057f1fb"></a><a id="t.37"></a><table class="c17"><tbody><tr class="c14"><td class="c57" colspan="1" rowspan="1"><p class="c5"><span class="c4">testing</span><span class="c2">.</span><span class="c4">lexicon </span><span class="c2">{</span><span class="c4"><br> &nbsp;tagAttribute </span><span class="c2">=</span><span class="c4">&nbsp;ENTITY_TYPE<br> &nbsp;hasConstraints </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c18">true</span><span class="c4"><br> &nbsp;probabilistic </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c18">true</span><span class="c4"><br> &nbsp;caseSensitive </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c18">false</span><span class="c4"><br> &nbsp;resource </span><span class="c2">=</span><span class="c4">&nbsp;classpath</span><span class="c2">:</span><span class="c4">com</span><span class="c2">/</span><span class="c4">davidbracewell</span><span class="c2">/</span><span class="c4">hermes</span><span class="c2">/</span><span class="c4">test</span><span class="c2">-</span><span class="c4">dic</span><span class="c2">.</span><span class="c4">csv<br>}</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>The lexicon in the example above can then be retrieved using the following code:</span></p><p class="c9 c8"><span></span></p><a id="t.f70fb1f4fb3d2ff35117c7606286e1e3884d2e39"></a><a id="t.38"></a><table class="c17"><tbody><tr class="c14"><td class="c57" colspan="1" rowspan="1"><p class="c5"><span class="c21">Lexicon</span><span class="c4">&nbsp;lexion </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c21">LexiconManager</span><span class="c2">.</span><span class="c4">getLexicon</span><span class="c2">(</span><span class="c23 c40">&quot;testing.lexicon&quot;</span><span class="c2">);</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>The lexicon manager allows for lexicons to be manually registered using the </span><span class="c1">register</span><span>&nbsp;method, but please note that this registration will not carry over to each node in a distributed environment. </span></p><p class="c9 c8"><span></span></p><a id="t.4d1d453c8ca9bad5d95a06f3c81f21247e707178"></a><a id="t.39"></a><table class="c17"><tbody><tr class="c14"><td class="c37" colspan="1" rowspan="1"><p class="c36"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 27.77px; height: 28.50px;"><img alt="bullseye.gif" src="images/image00.gif" style="width: 27.77px; height: 28.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c28" colspan="1" rowspan="1"><p class="c15 c9"><span>Take a look at </span><span class="c47">LeixconExample.java </span><span>i</span><span class="c13 c41">n the Hermes examples project to see examples of constructing and using lexicons.</span></p></td></tr></tbody></table><h2 class="c9 c38" id="h.v7uzt4um6la7-1"><span>Token-based Regular Expressions</span></h2><p class="c9"><span>Hermes provides a token-based regular expression engine that allows for matches on arbitrary annotation types, relation types, and attributes, while providing many of the operators that are possible using standard Java regular expressions. As with Java regular expressions, the token regular expression is specified as a string and is compiled into an instance of of </span><span class="c1">TokenRegex</span><span>. The resulting </span><span class="c1">TokenRegex</span><span>&nbsp;object can be used to create a </span><span class="c1">TokenMatcher</span><span>&nbsp;object that can match </span><span class="c1">HString</span><span>&nbsp;objects against the regular expression. State information is stored within the </span><span class="c1">TokenMatcher</span><span>&nbsp;allowing reuse of the </span><span class="c1">TokenRegex</span><span>&nbsp;object. An example of compiling a regular expression, creating a match, and iterating over the matches is as follows:</span><span><br></span></p><a id="t.84ed22def0773e8e9fb6641978f2621e3ad965cc"></a><a id="t.40"></a><table class="c17"><tbody><tr class="c14"><td class="c57" colspan="1" rowspan="1"><p class="c5"><span class="c21">TokenRegex</span><span class="c4">&nbsp;regex </span><span class="c2">=</span><span class="c4">&nbsp;</span><span class="c21">TokenRegex</span><span class="c2">.</span><span class="c4">compile</span><span class="c2">(</span><span class="c4">pattern</span><span class="c2">);</span><span class="c4"><br></span><span class="c21">TokenMatcher</span><span class="c4">&nbsp;matcher </span><span class="c2">=</span><span class="c4">&nbsp;regex</span><span class="c2">.</span><span class="c4">matcher</span><span class="c2">(</span><span class="c4">document</span><span class="c2">);</span><span class="c4"><br></span><span class="c18">while</span><span class="c4">&nbsp;</span><span class="c2">(</span><span class="c4">matcher</span><span class="c2">.</span><span class="c4">find</span><span class="c2">())</span><span class="c4">&nbsp;</span><span class="c2">{</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c21">System</span><span class="c2">.</span><span class="c18">out</span><span class="c2">.</span><span class="c4">println</span><span class="c2">(</span><span class="c4">matcher</span><span class="c2">.</span><span class="c18">group</span><span class="c2">());</span><span class="c4"><br>}</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>The following table lists the regular expression constructs that can be used.</span></p><p class="c9 c8"><span></span></p><a id="t.1099fd0830831ac788cfbdbc1b18839aae87fb1f"></a><a id="t.41"></a><table class="c17"><tbody><tr class="c14"><td class="c46" colspan="1" rowspan="1"><p class="c36"><span class="c44 c30">Construct</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c36"><span class="c44 c30">Matches</span></p></td></tr><tr class="c33"><td class="c57" colspan="2" rowspan="1"><p class="c5"><span class="c32">Content / Lemmas</span></p></td></tr><tr class="c14"><td class="c29" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">&ldquo;abc&rdquo;</span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">Case-sensitive Match character sequence abc to content of annotation (The quotes are optional when matching single tokens)</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">~</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">anything</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">/X/</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X as a Java regular expression over the content</span></p></td></tr><tr class="c14"><td class="c46" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">%LEXICON_NAME</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">Matches annotation content against a named lexicon</span></p></td></tr><tr class="c33"><td class="c57" colspan="2" rowspan="1"><p class="c5"><span class="c32">Annotations</span></p></td></tr><tr class="c55"><td class="c78" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">{ANNOTATION_TYPE X}</span></p></td><td class="c62" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X, matched against annotations of type ANNOTATION_TYPE on current token</span></p></td></tr><tr class="c14"><td class="c57" colspan="2" rowspan="1"><p class="c5"><span class="c32">Attributes</span></p></td></tr><tr class="c14"><td class="c29" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">$TAG_VALUE</span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">TAG with value TAG_VALUE </span></p></td></tr><tr class="c14"><td class="c46" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">$NAME:VALUE</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">Attribute named NAME with value VALUE</span></p></td></tr><tr class="c14"><td class="c57" colspan="2" rowspan="1"><p class="c5"><span class="c32">Relations </span></p></td></tr><tr class="c14"><td class="c29" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">(/&gt; X) </span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">Annotation whose parent relation matches X</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">@NAME:VALUE</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">Relation named NAME with value VALUE</span></p></td></tr><tr class="c14"><td class="c46" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">{@NAME:VALUE &nbsp; X }</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">Annotations containing a relation named NAME with value VALUE which matches X</span></p></td></tr><tr class="c77"><td class="c57" colspan="2" rowspan="1"><p class="c5"><span class="c32">Word Classes</span></p></td></tr><tr class="c14"><td class="c29" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">${PUNCT}</span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">Punctuation</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c9 c15"><span class="c13 c30">${NUMBER}</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">Numbers / Digits</span></p></td></tr><tr class="c14"><td class="c46" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">${STOPWORD}</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">Stopwords (language specific)</span></p></td></tr><tr class="c33"><td class="c57" colspan="2" rowspan="1"><p class="c5"><span class="c44 c30">Greedy Qualifiers</span></p></td></tr><tr class="c14"><td class="c29" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X?</span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X, zero or one time</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X*</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X, zero or more times</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X+</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X, one or more times</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X{y,z}</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X, y to z times</span></p></td></tr><tr class="c14"><td class="c46" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X{y,*}</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X, y times or more</span></p></td></tr><tr class="c33"><td class="c57" colspan="2" rowspan="1"><p class="c5"><span class="c32">Logical Operators</span></p></td></tr><tr class="c14"><td class="c29" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">X Y</span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X followed by Y</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">X &amp; Y</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">Both X and Y (single annotation logic)</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">X | Y</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">Either X or Y</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">(X)</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X, as a non-capturing group</span></p></td></tr><tr class="c75"><td class="c46" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">^X</span></p></td><td class="c51" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">Not X</span></p></td></tr><tr class="c33"><td class="c57" colspan="2" rowspan="1"><p class="c5"><span class="c32">Special Constructs</span></p></td></tr><tr class="c14"><td class="c29" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">(?&gt; X) </span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X, via zero-width positive look ahead</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">(?!&gt; X) </span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X, via zero-width negative look ahead</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">(?&lt;NAME&gt; &nbsp;X) </span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X, via a capture group named NAME</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">[ X ]</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">X, as a logical expression on the current token</span></p></td></tr><tr class="c14"><td class="c26" colspan="1" rowspan="1"><p class="c15 c9"><span class="c13 c30">(?il)</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c5"><span class="c13 c30">Nothing, but makes search case insensitive (i) or by lemma (l)</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><a id="t.197b2af8a8df0d4c070456ce63add77bbc3bfe89"></a><a id="t.42"></a><table class="c17"><tbody><tr class="c14"><td class="c37" colspan="1" rowspan="1"><p class="c36"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 27.77px; height: 28.50px;"><img alt="bullseye.gif" src="images/image00.gif" style="width: 27.77px; height: 28.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c28" colspan="1" rowspan="1"><p class="c15 c9"><span>Take a look at </span><span class="c47">TokenRegexExampl.java </span><span class="c13 c41">in the Hermes examples project to see example patterns.</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><h2 class="c9 c38" id="h.v7uzt4um6la7-2"><span>Caduceus</span></h2><p class="c9"><span>Caduceus, pronounced ca&middot;du&middot;ceus, is a rule-based information extraction system. &nbsp;Caduceus programs (a </span><span>list of rules</span><span>) are defined in YAML format with each file containing a list of rules. Rules define a name, a pattern, and optionally a set of annotation and/or relation rules. &nbsp;The name should be unique within a given Caduceus program (single YAML file) and is combined with the program file name and stored as </span><span class="c1">CADUCEUS_RULE</span><span>&nbsp;attribute on created annotations. Caduceus finds matches for the rule&rsquo;s pattern, which is defined using the token-based regular expression syntax, against an </span><span class="c1">HString</span><span>&nbsp;object. &nbsp;The matches are then used to construct annotations and relations. </span></p><p class="c9 c8"><span></span></p><p class="c9"><span>The annotations section of a Caduceus rule contains zero or more annotation rules, which define the capture group, &ldquo;*&rdquo; if capturing the entire pattern, the type of annotation to create, and a list of attributes to add to the annotation. An annotation may also provide a list of relations that must be added by the rule for the annotation to be added to the document. An example of a rule to create ENTITY annotations of type BODY_PART is as follows:</span></p><p class="c9 c8"><span></span></p><a id="t.8e5f2e078c005f6ba406cb3768ad165d0a8b47d0"></a><a id="t.43"></a><table class="c17"><tbody><tr class="c14"><td class="c57" colspan="1" rowspan="1"><p class="c5"><span class="c2">-</span><span class="c4">&nbsp;name</span><span class="c2">:</span><span class="c4">&nbsp;body_parts<br> &nbsp;pattern</span><span class="c2">:</span><span class="c4">&nbsp;</span><span class="c2">((?</span><span class="c4">i</span><span class="c2">)</span><span class="c4">eyes</span><span class="c2">|(?</span><span class="c4">i</span><span class="c2">)</span><span class="c4">ears|(?i)mouth|(?i)nose</span><span class="c2">)</span><span class="c4"><br> &nbsp;annotations</span><span class="c2">:</span><span class="c4"><br> &nbsp; &nbsp;</span><span class="c2">-</span><span class="c4">&nbsp;capture</span><span class="c2">:</span><span class="c4">&nbsp;</span><span class="c23 c40">&#39;*&#39;</span><span class="c4"><br> &nbsp; &nbsp; &nbsp;type</span><span class="c2">:</span><span class="c4">&nbsp;ENTITY<br> &nbsp; &nbsp; &nbsp;attributes</span><span class="c2">:</span><span class="c4">&nbsp;</span><span class="c2">[</span><span class="c4">ENTITY_TYPE</span><span class="c2">:</span><span class="c4">&nbsp;BODY_PART</span><span class="c2">,</span><span class="c4">&nbsp;CONFIDENCE</span><span class="c2">:</span><span class="c4">&nbsp;</span><span class="c23 c63">1.0]</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>An example of constructing an annotation from pattern with a named capture group is as follows:</span></p><p class="c9 c8"><span></span></p><a id="t.19a91fa4e7eec6f42205f5f36a8da184b7df1d51"></a><a id="t.44"></a><table class="c17"><tbody><tr class="c14"><td class="c57" colspan="1" rowspan="1"><p class="c5"><span class="c2">-</span><span class="c4">&nbsp;name</span><span class="c2">:</span><span class="c4">&nbsp;namedGroupExample<br> &nbsp;pattern</span><span class="c2">:</span><span class="c4">&nbsp;</span><span class="c23 c40">/Mrs?.?/</span><span class="c4">&nbsp;</span><span class="c2">(?&lt;</span><span class="c4">PERSON</span><span class="c2">&gt;</span><span class="c4">&nbsp;</span><span class="c2">(</span><span class="c4">$NNP </span><span class="c2">|</span><span class="c4">&nbsp;$NNPS</span><span class="c2">)+)</span><span class="c4"><br> &nbsp;annotations</span><span class="c2">:</span><span class="c4"><br> &nbsp; &nbsp;</span><span class="c2">-</span><span class="c4">&nbsp;capture</span><span class="c2">:</span><span class="c4">&nbsp;PERSON<br> &nbsp; &nbsp; &nbsp;type</span><span class="c2">:</span><span class="c4">&nbsp;ENTITY<br> &nbsp; &nbsp; &nbsp;attributes</span><span class="c2">:</span><span class="c4">&nbsp;</span><span class="c2">[</span><span class="c4">ENTITY_TYPE</span><span class="c2">:</span><span class="c4">&nbsp;PERSON</span><span class="c2">,</span><span class="c4">&nbsp;CONFIDENCE</span><span class="c2">:</span><span class="c4">&nbsp;</span><span class="c23 c63">1.0]</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>The relations section of a Caduceus rule contains zero or more relation rules, which define the relation name, other relation rule names that must match in order for the defined relation to be added, a type and value, and the source and target of the relation. &nbsp;The name is used in other relation rules &ldquo;requires&rdquo; field, which provides a filter for relations to only be added when another named relation rule is successful. The type and value fields are the name of the </span><span class="c1">RelationType</span><span>&nbsp;to create and the value of the type assigned to the relation. </span></p><p class="c9 c8"><span></span></p><p class="c9"><span>Relations have a source and a target (sometimes referred to as a child and parent respectively). A relation rule must define both the source and target. A source and target can either be defined as a capture group, or optionally &ldquo;*&rdquo;, within the matched pattern or via a relation to the matched group. &nbsp;In both cases, an annotation type can be provided to specify the type of annotation to apply the relation (by default the TOKEN annotation type is used). Additionally, a constraint can be placed on the source or target which is a simplified single token regular expression. An example of a relation rule that uses capture groups is as follows:</span></p><p class="c9 c8"><span></span></p><a id="t.092a6c31930cf18df9bd2a50d0c219d267bd5c13"></a><a id="t.45"></a><table class="c17"><tbody><tr class="c14"><td class="c57" colspan="1" rowspan="1"><p class="c5"><span class="c2">-</span><span class="c4">&nbsp;name</span><span class="c2">:</span><span class="c4">&nbsp;born_in<br> &nbsp;pattern</span><span class="c2">:</span><span class="c4">&nbsp;</span><span class="c2">(?&lt;</span><span class="c23">PER</span><span class="c2">&gt;{</span><span class="c4">ENTITY $PERSON</span><span class="c2">})</span><span class="c4">&nbsp;</span><span class="c4">born </span><span class="c18">in</span><span class="c4">&nbsp;</span><span class="c2">(?&lt;</span><span class="c23">LOC</span><span class="c2">&gt;{</span><span class="c4">ENTITY $LOCATION</span><span class="c2">})</span><span class="c4"><br> &nbsp;relations</span><span class="c2">:</span><span class="c4"><br> &nbsp; &nbsp;</span><span class="c2">-</span><span class="c4">&nbsp;name</span><span class="c2">:</span><span class="c4">&nbsp;born_in_relation<br> &nbsp; &nbsp; &nbsp;type</span><span class="c2">:</span><span class="c4">&nbsp;RELATION<br> &nbsp; &nbsp; &nbsp;value</span><span class="c2">:</span><span class="c4">&nbsp;BORN_IN<br> &nbsp; &nbsp; &nbsp;source</span><span class="c2">:</span><span class="c4"><br> &nbsp; &nbsp; &nbsp; &nbsp;capture</span><span class="c2">:</span><span class="c4">&nbsp;PER<br> &nbsp; &nbsp; &nbsp; &nbsp;annotation</span><span class="c2">:</span><span class="c4">&nbsp;ENTITY<br> &nbsp; &nbsp; &nbsp;target</span><span class="c2">:</span><span class="c4"><br> &nbsp; &nbsp; &nbsp; &nbsp;capture</span><span class="c2">:</span><span class="c4">&nbsp;LOC<br> &nbsp; &nbsp; &nbsp; &nbsp;annotation</span><span class="c2">:</span><span class="c4">&nbsp;ENTITY</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>In the example given above, the pattern will match a PERSON entity mention followed by the phrase born in followed by a LOCATION entity mention. Given the match, the born_in_relation rule will fire and create a relation of type RELATION and value BORN_ON between the PERSON and LOCATION entity. &nbsp;A more complex example that uses relations and constraints for source and target is as follows:</span></p><p class="c9 c8"><span></span></p><a id="t.d1a9a60bbf8afbd1485ba9fa859c5564bd27ff64"></a><a id="t.46"></a><table class="c31"><tbody><tr class="c14"><td class="c12" colspan="1" rowspan="1"><p class="c5"><span class="c22">-</span><span class="c6">&nbsp;name</span><span class="c22">:</span><span class="c13 c6">&nbsp;spookEvent</span></p><p class="c5"><span class="c6">&nbsp; pattern</span><span class="c22">:</span><span class="c6">&nbsp;</span><span class="c22">[</span><span class="c6">&nbsp;</span><span class="c67 c40">/^spook/</span><span class="c6">&nbsp;</span><span class="c22">&amp;</span><span class="c6">&nbsp;$VERB</span><span class="c22">]</span><span class="c6">&nbsp;</span><span class="c67 c54">#Match the word spook when it&#39;s a verb</span></p><p class="c5"><span class="c13 c6">&nbsp; annotations:</span></p><p class="c5"><span class="c6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c22">-</span><span class="c6">&nbsp;capture</span><span class="c22">:</span><span class="c6">&nbsp;</span><span class="c67 c40">&quot;*&quot;</span><span class="c13 c6">&nbsp;</span></p><p class="c5"><span class="c6">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;type</span><span class="c22">:</span><span class="c13 c6">&nbsp;EVENT</span></p><p class="c5"><span class="c6">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;attributes</span><span class="c22">:</span><span class="c6">&nbsp;</span><span class="c22">[</span><span class="c6">TAG</span><span class="c22">:</span><span class="c13 c6">&nbsp;SPOOK_EVENT]</span></p><p class="c5"><span class="c13 c6">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;requires: [spooker, spookee]</span></p><p class="c5"><span class="c13 c6">&nbsp; relations:</span></p><p class="c5"><span class="c6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c22">-</span><span class="c6">&nbsp;name</span><span class="c22">:</span><span class="c6">&nbsp;spookee </span></p><p class="c5"><span class="c6">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type</span><span class="c22">:</span><span class="c13 c6">&nbsp;EVENT_ROLE</span></p><p class="c5"><span class="c6">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value</span><span class="c22">:</span><span class="c13 c6">&nbsp;SPOOKEE</span></p><p class="c5"><span class="c13 c6">&nbsp; &nbsp; &nbsp; &nbsp; requires: spooker</span></p><p class="c5"><span class="c6">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class="c67">s</span><span class="c13 c6">ource:</span></p><p class="c5"><span class="c6">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;relation</span><span class="c22">:</span><span class="c6">&nbsp;DEPENDENCY</span><span class="c22">:</span><span class="c13 c6">dobj</span></p><p class="c5"><span class="c6">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;annotation</span><span class="c22">:</span><span class="c13 c6">&nbsp;PHRASE_CHUNK &nbsp;</span></p><p class="c5"><span class="c6">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;constraint</span><span class="c22">:</span><span class="c13 c6">&nbsp;$NOUN </span></p><p class="c5"><span class="c13 c6">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target:</span></p><p class="c5"><span class="c6">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;capture</span><span class="c22">:</span><span class="c6">&nbsp;</span><span class="c67 c40">&quot;*&quot;</span></p><p class="c5"><span class="c6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c22">-</span><span class="c6">&nbsp;name</span><span class="c22">:</span><span class="c13 c6">&nbsp;spooker </span></p><p class="c5"><span class="c6">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type</span><span class="c22">:</span><span class="c13 c6">&nbsp;EVENT_ROLE</span></p><p class="c5"><span class="c6">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value</span><span class="c22">:</span><span class="c13 c6">&nbsp;SPOOKER</span></p><p class="c5"><span class="c13 c6">&nbsp; &nbsp; &nbsp; &nbsp; requires: spookee</span></p><p class="c5"><span class="c13 c6">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; source:</span></p><p class="c5"><span class="c6">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;relation</span><span class="c22">:</span><span class="c6">&nbsp;DEPENDENCY</span><span class="c22">:</span><span class="c13 c6">nsubj</span></p><p class="c5"><span class="c6">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;annotation</span><span class="c22">:</span><span class="c13 c6">&nbsp;PHRASE_CHUNK &nbsp;</span></p><p class="c5"><span class="c6">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;constraint</span><span class="c22">:</span><span class="c13 c6">&nbsp;$NOUN </span></p><p class="c5"><span class="c13 c6">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target:</span></p><p class="c5"><span class="c6">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;capture</span><span class="c22">:</span><span class="c6">&nbsp;</span><span class="c67 c40">&quot;*&quot;</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9"><span>Notice that the annotation rule requires both relation rules to fire in order for the annotation to be added to the document. Also the </span><span class="c1">spookee </span><span>relation rule requires the </span><span class="c1">spooker</span><span>&nbsp;rule to fire and vice versa, which means that the verb </span><span class="c1">spook</span><span>&nbsp;must have a subject and direct object for both relations to be added (e.g. &ldquo;He was spooked.&rdquo; would not fire).</span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><a id="t.72108c148cb7e8277326fab24110b347af26378b"></a><a id="t.47"></a><table class="c17"><tbody><tr class="c14"><td class="c37" colspan="1" rowspan="1"><p class="c36"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 27.77px; height: 28.50px;"><img alt="bullseye.gif" src="images/image00.gif" style="width: 27.77px; height: 28.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c28" colspan="1" rowspan="1"><p class="c15 c9"><span>Take a look at </span><span class="c47">CaduceusExample.java </span><span class="c13 c41">in the Hermes examples project to see an examples using the Caduceus program listed in this section.</span></p></td></tr></tbody></table><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><p class="c9 c8"><span></span></p><div><p class="c9 c8 c49"><span></span></p></div></body></html>